#' PX-DA MCMC routine to sample from HBMRVAR model
#'
#' @param formula an object of class "formula"; a symbolic description of the model to be fitted
#' @param data a dataframe containing outcome variables, covariates, and a patient or subject identifier
#' @param ordinal_outcomes a character string containing the names of the ordinal outcomes
#' @param patient_var name of the patient or subject identifier
#' @param sig_prior prior variance on the regression coefficients
#' @param all_draws logical with a default of FALSE which discards burn-in
#' @param nsim positive integer, number of iterations with default of 1000
#' @param burn_in positive integer, number of iterations to remove with default of 100. Must be >= 100.
#' @param thin positive integer, specifiers the period of saving samples. Default of 20 due to the high autocorrelation of the cutpoints
#' @param seed positive integer, seed for random number generation
#' @param verbose logical, print iteration number to keep track of progress
#' @param max_iter_rej maximum number of rejection algorithm attempts for multivariate truncated normal
#' @return mcmc
#' @importFrom zoo na.approx
#' @importFrom fastDummies dummy_cols
#' @importFrom magic adiag
#' @importFrom lme4 lmer VarCorr
#' @export

baseline_bmr2 <- function(formula, data, ordinal_outcome = c("y_ord"),
                          time_var = "time", patient_var = "patient_idx",
                          random_slope = F, ar_cov = TRUE, nsim = 1000,
                          burn_in = 100, thin = 10, seed = 14, verbose = TRUE,
                          sig_prior = 1000000000, sd_vec = c(0.15, 0.30)) {

  ## Create storage
  set.seed(seed)
  bmrarm_start(env = environment())
  cont_out_var <- setdiff(out_vars, ordinal_outcome)

  ## Starting values for ordinal outcome
  y[1:N_obs, 1] <- 0.5 + res_cuts[z, 1]
  y[is.infinite(y[, 1]), 1] <- -0.5
  y[is.na(y[, 1]), 1] <- 0

  ## Starting values for continuous outcomes
  df <- data.frame(patient = samp_info$pat_idx_long, y = as.numeric(y),
                   outcome = rep(1:N_outcomes, each = N_obs)) %>%
    group_by(patient, outcome) %>%
    mutate(y_interp = na.approx(y, na.rm = FALSE),
           y_interp = ifelse(!is.na(y_interp), y_interp,
                             ifelse(row_number() == n(),
                                    lag(y_interp), lead(y_interp))))
  y <- matrix(df$y_interp, ncol = N_outcomes)
  y[is.na(y)] <- 0
  i <- 2
  samp_info$burn_in <- burn_in
  samp_info$max_iter <- 10000000

  ## Emprical bayes priors for the random effects covariance matrix
  if(random_slope) {
    form_string <- paste0("~ . + (", time_var, "|", patient_var, ")")
  } else {
    form_string <- paste0("~ . + (1|", patient_var, ")")
  }
  form_use <- update(formula, as.formula(form_string))

  ## Fit models
  ord_form <- reformulate(deparse(form_use[[3]]), response = ordinal_outcome)
  cont_form <- reformulate(deparse(form_use[[3]]), response = cont_out_var)
  ord_mod <- lmer(ord_form, data = data)
  cont_mod <- lmer(cont_form, data = data)

  ## Prior for
  priors <- c(as.data.frame(VarCorr(ord_mod))[1:N_pat_effects, "vcov"],
              as.data.frame(VarCorr(cont_mod))[1:N_pat_effects, "vcov"])
  prior_mat <- diag(priors) * N_pat_effects

  for(i in 2:nsim) {
    samp_info$num_iter <- i

    ## Regression coefficients
    vals <- bmrarm_fc_sig_beta(y, X, Z_kron, cur_draws, samp_info)
    #print("sb")
    res_beta[, i] <- cur_draws$beta <- vals$beta
    res_sig[, i] <- cur_draws$sigma <- vals$sig

    # Autoregressive parameter
    if(samp_info$ar_cov) {
      vals <- bmrarm_mh_ar(y, X, Z_kron, cur_draws, samp_info)
      #print("ar")
      res_ar[i] <- cur_draws$ar <- vals$ar
      res_accept[i, 2] <- vals$accept
    }

    ## Subject specific effects
    vals <- bmrarm_fc_patient2(y, z, X, cur_draws, samp_info, prior_mat)
    res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
    res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects
    #res_pat_sig_sd[, i] <- cur_draws$pat_sig_sd <- vals$pat_sig_sd
    #print(head(cur_draws$pat_effects))

    ## Latent values, missing values, cut points
    y_cuts <- bmrarm_fc_y_cuts(y, z, X, Z_kron, cur_draws, samp_info)
    #print("y")
    y <-  res_y[,, i] <- y_cuts$y
    res_cuts[, i] <- cur_draws$cuts <- y_cuts$cuts
    res_accept[i, 1] <- y_cuts$accept

    ## Update missing values
    y <- res_y[,, i]<- bmrarm_fc_missing(y, z, X, Z_kron, cur_draws, samp_info)
    #print("miss")

    ## Cut points
    #if(i %% 50 == 0) print(i)
    #if(i %% 100 == 50) plot(res_cuts[4, ], type = "l")
    if(i %% 100 == 50) plot(res_ar, type = "l")
    if(i %% 100 == 0) plot(res_pat_sig[1, ], type = "l")
  }

  sim_use <- seq(burn_in + 1, nsim, by = thin)
  draws <- list(
    res_cuts = res_cuts[, sim_use],
    res_beta = res_beta[, sim_use],
    res_pat_sig = res_pat_sig[, sim_use],
    res_ar = res_ar[sim_use],
    res_sigma = res_sig[, sim_use],
    res_y = res_y[,, sim_use],
    res_pat_eff = res_pat_eff[,, sim_use],
    res_accept = res_accept[sim_use, ],
    samp_info = samp_info,
    X = X,
    Z_kron = Z_kron, z = z)
  draws
}


#' PX-DA MCMC routine to sample from HBMRVAR model
#'
#' @param formula an object of class "formula"; a symbolic description of the model to be fitted
#' @param data a dataframe containing outcome variables, covariates, and a patient or subject identifier
#' @param ordinal_outcomes a character string containing the names of the ordinal outcomes
#' @param patient_var name of the patient or subject identifier
#' @param sig_prior prior variance on the regression coefficients
#' @param all_draws logical with a default of FALSE which discards burn-in
#' @param nsim positive integer, number of iterations with default of 1000
#' @param burn_in positive integer, number of iterations to remove with default of 100. Must be >= 100.
#' @param thin positive integer, specifiers the period of saving samples. Default of 20 due to the high autocorrelation of the cutpoints
#' @param seed positive integer, seed for random number generation
#' @param verbose logical, print iteration number to keep track of progress
#' @param max_iter_rej maximum number of rejection algorithm attempts for multivariate truncated normal
#' @return mcmc
#' @importFrom zoo na.approx
#' @importFrom fastDummies dummy_cols
#' @importFrom magic adiag
#' @export

baseline_bmr3 <- function(formula, data, ordinal_outcome = c("y_ord"),
                          time_var = "time", patient_var = "patient_idx",
                          random_slope = F, ar_cov = TRUE, nsim = 1000,
                          burn_in = 100, thin = 10, seed = 14, verbose = TRUE,
                          sig_prior = 1000000000, sd_vec = c(0.15, 0.30)) {

  ## Create storage
  set.seed(seed)
  bmrarm_start(env = environment())

  ## Starting values for ordinal outcome
  y[1:N_obs, 1] <- 0.5 + res_cuts[z, 1]
  y[is.infinite(y[, 1]), 1] <- -0.5
  y[is.na(y[, 1]), 1] <- 0

  ## Starting values for continuous outcomes
  df <- data.frame(patient = samp_info$pat_idx_long, y = as.numeric(y),
                   outcome = rep(1:N_outcomes, each = N_obs)) %>%
    group_by(patient, outcome) %>%
    mutate(y_interp = na.approx(y, na.rm = FALSE),
           y_interp = ifelse(!is.na(y_interp), y_interp,
                             ifelse(row_number() == n(),
                                    lag(y_interp), lead(y_interp))))
  y <- matrix(df$y_interp, ncol = N_outcomes)
  y[is.na(y)] <- 0
  i <- 2
  samp_info$burn_in <- burn_in
  samp_info$max_iter <- 10000000
  for(i in 2:nsim) {
    samp_info$num_iter <- i

    ## Regression coefficients
    vals <- bmrarm_fc_sig_beta(y, X, Z_kron, cur_draws, samp_info)
    #print("sb")
    res_beta[, i] <- cur_draws$beta <- vals$beta
    res_sig[, i] <- cur_draws$sigma <- vals$sig

    # Autoregressive parameter
    if(samp_info$ar_cov) {
      vals <- bmrarm_mh_ar(y, X, Z_kron, cur_draws, samp_info)
      #print("ar")
      res_ar[i] <- cur_draws$ar <- vals$ar
      res_accept[i, 2] <- vals$accept
    }

    ## Subject specific effects
    vals <- bmrarm_fc_patient4(y, z, X, cur_draws, samp_info)
    #res_pat_sig[, i] <- cur_draws$pat_sig <- sim_data$sig_alpha
    #res_pat_sig[, i] <- cur_draws$pat_sig <- sim_data$sig_alpha
    res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects
    res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
    res_pat_sig_sd[, i] <- cur_draws$pat_sig_sd <- vals$pat_sig_sd
    #print(head(cur_draws$pat_effects))

    ## Latent values, missing values, cut points
    y_cuts <- bmrarm_fc_y_cuts(y, z, X, Z_kron, cur_draws, samp_info)
    #print("y")
    y <-  res_y[,, i] <- y_cuts$y
    res_cuts[, i] <- cur_draws$cuts <- y_cuts$cuts
    res_accept[i, 1] <- y_cuts$accept

    ## Update missing values
    y <- res_y[,, i]<- bmrarm_fc_missing(y, z, X, Z_kron, cur_draws, samp_info)
    #print("miss")

    ## Cut points
    #if(i %% 50 == 0) print(i)
    #if(i %% 100 == 50) plot(res_cuts[4, ], type = "l")
    if(i %% 100 == 50) plot(res_ar, type = "l")
    if(i %% 100 == 0) plot(res_pat_sig[1, ], type = "l")
  }

  sim_use <- seq(burn_in + 1, nsim, by = thin)
  draws <- list(
    res_cuts = res_cuts[, sim_use],
    res_beta = res_beta[, sim_use],
    res_pat_sig = res_pat_sig[, sim_use],
    res_ar = res_ar[sim_use],
    res_sigma = res_sig[, sim_use],
    res_y = res_y[,, sim_use],
    res_pat_sig_sd = res_pat_sig_sd[, sim_use],
    res_pat_eff = res_pat_eff[,, sim_use],
    res_accept = res_accept[sim_use, ],
    samp_info = samp_info,
    X = X,
    Z_kron = Z_kron, z = z)
  draws
}

#' PX-DA MCMC routine to sample from HBMRVAR model
#'
#' @param formula an object of class "formula"; a symbolic description of the model to be fitted
#' @param data a dataframe containing outcome variables, covariates, and a patient or subject identifier
#' @param ordinal_outcomes a character string containing the names of the ordinal outcomes
#' @param patient_var name of the patient or subject identifier
#' @param sig_prior prior variance on the regression coefficients
#' @param all_draws logical with a default of FALSE which discards burn-in
#' @param nsim positive integer, number of iterations with default of 1000
#' @param burn_in positive integer, number of iterations to remove with default of 100. Must be >= 100.
#' @param thin positive integer, specifiers the period of saving samples. Default of 20 due to the high autocorrelation of the cutpoints
#' @param seed positive integer, seed for random number generation
#' @param verbose logical, print iteration number to keep track of progress
#' @param max_iter_rej maximum number of rejection algorithm attempts for multivariate truncated normal
#' @return mcmc
#' @importFrom zoo na.approx
#' @importFrom fastDummies dummy_cols
#' @importFrom magic adiag
#' @export

baseline_bmr_test2 <- function(formula, data, ordinal_outcome = c("y_ord"),
                               time_var = "time", patient_var = "patient_idx",
                               random_slope = F, ar_cov = TRUE, nsim = 1000,
                               burn_in = 100, thin = 10, seed = 14, verbose = TRUE,
                               sig_prior = 1000000000, sd_vec = c(0.15, 0.05),
                               which_fc = c(T, T, T, T, T), base0 = F) {

  ## Create storage
  set.seed(seed)
  bmrarm_start(env = environment())

  ## Starting values for ordinal outcome
  y[1:N_obs, 1] <- 0.5 + res_cuts[z, 1]
  y[is.infinite(y[, 1]), 1] <- -0.5
  y[is.na(y[, 1]), 1] <- 0

  ## Starting values for continuous outcomes
  df <- data.frame(patient = samp_info$pat_idx_long, y = as.numeric(y),
                   outcome = rep(1:N_outcomes, each = N_obs)) %>%
    group_by(patient, outcome) %>%
    mutate(y_interp = na.approx(y, na.rm = FALSE),
           y_interp = ifelse(!is.na(y_interp), y_interp,
                             ifelse(row_number() == n(),
                                    lag(y_interp), lead(y_interp))))
  y <- matrix(df$y_interp, ncol = N_outcomes)
  y[is.na(y)] <- 0
  i <- 2
  cur_draws$beta <- matrix(as.numeric(sim_data$beta), 2)
  cur_draws$sigma <- sim_data$sigma
  cur_draws$ar <- sim_data$ar
  if(base0) cur_draws$ar <- 0
  cur_draws$pat_effects <- sim_data$alpha
  cur_draws$pat_sig <- sim_data$sig_alpha
  cur_draws$cuts <- sim_data$cuts
  samp_info$burn_in <- burn_in
  samp_info$max_iter <- 10000000
  y <- cbind(sim_data$truth$y1, sim_data$truth$y2)
  for(i in 2:nsim) {
    samp_info$num_iter <- i

    ## Regression coefficients
    if(which_fc[1]) {
      vals <- bmrarm_fc_sig_beta(y, X, Z_kron, cur_draws, samp_info)
      #print("sb")
      res_beta[, i] <- cur_draws$beta <- vals$beta
      res_sig[, i] <- cur_draws$sigma <- vals$sig
      #res_sig_sd[, i] <- cur_draws$sig_sd <- vals$sig_sd
    } else {
      res_beta[, i] <- cur_draws$beta
      res_sig[, i] <- cur_draws$sigma
    }

    # Autoregressive parameter
    if(samp_info$ar_cov & which_fc[2]) {
      vals <- bmrarm_mh_ar(y, X, Z_kron, cur_draws, samp_info)
      #print("ar")
      res_ar[i] <- cur_draws$ar <- vals$ar
      res_accept[i, 2] <- vals$accept
      #cur_draws$ar <- 0
    } else {
      res_ar[i] <- cur_draws$ar
    }

    ## Subject specific effects
    if(which_fc[3]) {
      vals <- bmrarm_fc_patient4(y, z, X, cur_draws, samp_info)
      #print("pat")
      res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
      res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects
      res_pat_sig_sd[, i] <- cur_draws$pat_sig_sd <- vals$pat_sig_sd
      #res_pat_sig_q[, i] <- vals$pat_sig_q
      #res_accept[i, 3:6] <- vals$accept_vec
      #res_pat_sig[, i] <- cur_draws$pat_sig
    } else {
      res_pat_sig[, i] <- cur_draws$pat_sig
      res_pat_eff[,, i] <- cur_draws$pat_effects
    }

    ## Latent values, missing values, cut points
    if(which_fc[4]) {
      y_cuts <- bmrarm_fc_y_cuts(y, z, X, Z_kron, cur_draws, samp_info)
      #print("y")
      y <-  res_y[,, i] <- y_cuts$y
      res_cuts[, i] <- cur_draws$cuts <- y_cuts$cuts
      res_accept[i, 1] <- y_cuts$accept
    } else {
      res_y[,, i] <- y
      res_cuts[, i] <- cur_draws$cuts
    }

    ## Update missing values
    if(which_fc[5]) {
      y <- res_y[,, i]<- bmrarm_fc_missing(y, z, X, Z_kron, cur_draws, samp_info)
    }
    #print("miss")

    ## Cut points
    if(i %% 50 == 0) print(i)
    #if(i %% 100 == 50) plot(res_cuts[4, ], type = "l")
    if(i %% 100 == 50) plot(res_ar, type = "l")
    if(i %% 100 == 0) plot(res_pat_sig[1, ], type = "l")
  }

  sim_use <- seq(burn_in + 1, nsim, by = thin)
  draws <- list(
    res_cuts = res_cuts[, sim_use],
    res_beta = res_beta[, sim_use],
    res_pat_sig = res_pat_sig,
    res_ar = res_ar[sim_use],
    res_sigma = res_sig[, sim_use],
    res_pat_sig_q = res_pat_sig_q[, sim_use],
    res_pat_sig_sd = res_pat_sig_sd[, sim_use],
    res_y = res_y[,, sim_use],
    res_pat_eff = res_pat_eff[,, sim_use],
    samp_info = samp_info,
    res_accept = res_accept[sim_use, ],
    X = X,
    Z_kron = Z_kron, z = z)
  draws
}

#' Full conditional draws of the latent continuous values
#'
#' @param y matrix of multivariate observations
#' @param z matrix of ordinal voutcomes
#' @param sig covariance matrix for the VAR process
#' @param sig0 for the initial values
#' @param M transition matrix for the VAR(1) component
#' @param cuts current threshold values
#' @param miss_mat locations of missing values
#' @param samp_info information for which locations to sample
#' @param num_iter current iteration number
#' @import tmvtnorm
#' @return matrix
#' @export

bmrarm_fc_patient2 <- function(y, z, X, cur_draws, samp_info, prior_mat) {

  ## Generate full sigma matrix
  N_pat <- samp_info$N_pat
  sig_alpha_inv <- chol2inv(chol(cur_draws$pat_sig))
  sig_inv <- chol2inv(chol(cur_draws$sigma))
  resid_mat <- y - X %*% cur_draws$beta
  N_pat_eff <- ncol(samp_info$pat_z_kron[[1]])

  ## Sigma inverses only needed is autoregressive covariance matrix
  if(samp_info$ar_cov) {
    sig_list <- get_sig_list(cur_draws, samp_info)
  }

  ## Patient effects
  res <- matrix(NA, nrow = N_pat, ncol = N_pat_eff)

  for(i in 1:N_pat) {
    ## Get locations and time matrix for patient
    locs <- samp_info$pat_locs[[i]]
    time_ind <- samp_info$pat_time_ind[i]
    resid_vec <- as.numeric(resid_mat[locs, ])
    pat_Z <- samp_info$pat_z_kron[[i]]

    ## Patient specific covariance matrix
    if(samp_info$ar_cov) {
      pat_sig_inv <- sig_list$sig_inv_list[[time_ind]]
    } else {
      pat_sig_inv <- kronecker(sig_inv, diag(rep(1, samp_info$pat_N_obs[[i]])))
    }

    ## Cross products, covariance, alpha hat
    Z_sig_prod <- crossprod(pat_Z, pat_sig_inv)
    post_cov <- chol2inv(chol(Z_sig_prod %*% pat_Z + sig_alpha_inv))
    post_mean <- post_cov %*% Z_sig_prod %*% resid_vec
    L <- t(chol(post_cov))
    res[i, ] <- L %*% rnorm(length(post_mean)) + post_mean
  }

  ## New Covariance matrix for patient specific effects
  pat_sig <- rinvwishart(N_pat + N_pat_eff,
                         crossprod(res) + prior_mat)
  list(pat_effects = res, pat_sig = pat_sig)
}

#' Full conditional draws of the latent continuous values
#'
#' @param y matrix of multivariate observations
#' @param z matrix of ordinal voutcomes
#' @param sig covariance matrix for the VAR process
#' @param sig0 for the initial values
#' @param M transition matrix for the VAR(1) component
#' @param cuts current threshold values
#' @param miss_mat locations of missing values
#' @param samp_info information for which locations to sample
#' @param num_iter current iteration number
#' @import tmvtnorm
#' @return matrix
#' @export

bmrarm_fc_patient3 <- function(y, z, X, cur_draws, samp_info) {

  ## Generate full sigma matrix
  N_pat <- samp_info$N_pat
  sig_alpha_inv <- chol2inv(chol(cur_draws$pat_sig))
  sig_inv <- chol2inv(chol(cur_draws$sigma))
  resid_mat <- y - X %*% cur_draws$beta
  N_pat_eff <- ncol(samp_info$pat_z_kron[[1]])

  ## Sigma inverses only needed is autoregressive covariance matrix
  if(samp_info$ar_cov) {
    sig_list <- get_sig_list(cur_draws, samp_info)
  }

  ## Patient effects
  res <- matrix(NA, nrow = N_pat, ncol = N_pat_eff)

  for(i in 1:N_pat) {
    ## Get locations and time matrix for patient
    locs <- samp_info$pat_locs[[i]]
    time_ind <- samp_info$pat_time_ind[i]
    resid_vec <- as.numeric(resid_mat[locs, ])
    pat_Z <- samp_info$pat_z_kron[[i]]

    ## Patient specific covariance matrix
    if(samp_info$ar_cov) {
      pat_sig_inv <- sig_list$sig_inv_list[[time_ind]]
    } else {
      pat_sig_inv <- kronecker(sig_inv, diag(rep(1, samp_info$pat_N_obs[[i]])))
    }

    ## Cross products, covariance, alpha hat
    Z_sig_prod <- crossprod(pat_Z, pat_sig_inv)
    post_cov <- chol2inv(chol(Z_sig_prod %*% pat_Z + sig_alpha_inv))
    post_mean <- post_cov %*% Z_sig_prod %*% resid_vec
    L <- t(chol(post_cov))
    res[i, ] <- L %*% rnorm(length(post_mean)) + post_mean
  }

  ## Correlation matrix
  sd_inv <- diag(1 / cur_draws$pat_sig_sd)
  pat_sig_q <- rinvwishart(N_pat + N_pat_eff + 1,
                           sd_inv %*% crossprod(res) %*% sd_inv +
                             diag(rep(1, 4)))

  ## SD parameters
  accept_vec <- rep(0, N_pat_eff)
  for(i in 1:N_pat_eff) {
    ## Propose new values
    cur_draws2 <- cur_draws
    cur_draws2$pat_sig_sd[i] <- exp(rnorm(1, log(cur_draws2$pat_sig_sd[i]),
                                          sd = samp_info$sd_pat_sd))
    cur_draws2$pat_sig <- diag(cur_draws2$pat_sig_sd) %*% pat_sig_q %*% diag(cur_draws2$pat_sig_sd)

    ## Calculate comparison values
    pat_inv_old <- chol2inv(chol(cur_draws$pat_sig))
    pat_inv_new <- chol2inv(chol(cur_draws2$pat_sig))

    comp_old <- N_pat / 2 * determinant(pat_inv_old, logarithm = T)[[1]][1] -
      0.5 * sum(diag(res %*% pat_inv_old %*% t(res))) +
      dnorm(log(cur_draws$pat_sig_sd[i]), 0, sd = 10000, log = T)

    comp_new <- N_pat / 2 * determinant(pat_inv_new, logarithm = T)[[1]][1] -
      0.5 * sum(diag(res %*% pat_inv_new %*% t(res))) +
      dnorm(log(cur_draws2$pat_sig_sd[i]), 0, sd = 10000, log = T)
    compar_val <- comp_new - comp_old

    if(compar_val >= log(runif(1))) {
      cur_draws$pat_sig_sd[i] <- cur_draws2$pat_sig_sd[i]
      accept_vec[i] <- 1
    }
  }

  # ## SD parameters
  # accept_vec <- rep(0, N_pat_eff)
  # ## Propose new values
  # cur_draws2 <- cur_draws
  # cur_draws2$pat_sig_sd <- exp(rnorm(N_pat_eff, log(cur_draws2$pat_sig_sd),
  #                                       sd = samp_info$sd_pat_sd))
  # cur_draws2$pat_sig <- diag(cur_draws2$pat_sig_sd) %*% pat_sig_q %*% diag(cur_draws2$pat_sig_sd)
  #
  # ## Calculate comparison values
  # pat_inv_old <- chol2inv(chol(cur_draws$pat_sig))
  # pat_inv_new <- chol2inv(chol(cur_draws2$pat_sig))
  #
  # comp_old <- N_pat / 2 * determinant(pat_inv_old, logarithm = T)[[1]][1] -
  #   0.5 * sum(diag(res %*% pat_inv_old %*% t(res)))
  #
  # comp_new <- N_pat / 2 * determinant(pat_inv_new, logarithm = T)[[1]][1] -
  #   0.5 * sum(diag(res %*% pat_inv_new %*% t(res)))
  # compar_val <- comp_new - comp_old
  #
  # if(compar_val >= log(runif(1))) {
  #   cur_draws$pat_sig_sd <- cur_draws2$pat_sig_sd
  #   accept_vec <- 1
  # }

  cur_draws$pat_sig_sd <- c(cur_draws$pat_sig_sd[1] , 1, 1, 1)
  list(pat_effects = res,
       pat_sig = diag(cur_draws$pat_sig_sd) %*% pat_sig_q %*% diag(cur_draws$pat_sig_sd),
       pat_sig_sd = cur_draws$pat_sig_sd, accept_vec = accept_vec, pat_sig_q = pat_sig_q)
}

#' Full conditional draws of the latent continuous values
#'
#' @param y matrix of multivariate observations
#' @param z matrix of ordinal voutcomes
#' @param sig covariance matrix for the VAR process
#' @param sig0 for the initial values
#' @param M transition matrix for the VAR(1) component
#' @param cuts current threshold values
#' @param miss_mat locations of missing values
#' @param samp_info information for which locations to sample
#' @param num_iter current iteration number
#' @import tmvtnorm
#' @return matrix
#' @export

bmrarm_fc_patient4 <- function(y, z, X, cur_draws, samp_info) {

  ## Generate full sigma matrix
  N_pat <- samp_info$N_pat
  sig_alpha_inv <- chol2inv(chol(cur_draws$pat_sig))
  sig_inv <- chol2inv(chol(cur_draws$sigma))
  resid_mat <- y - X %*% cur_draws$beta
  N_pat_eff <- ncol(samp_info$pat_z_kron[[1]])

  ## Sigma inverses only needed is autoregressive covariance matrix
  if(samp_info$ar_cov) {
    sig_list <- get_sig_list(cur_draws, samp_info)
  }

  ## Patient effects
  res <- matrix(NA, nrow = N_pat, ncol = N_pat_eff)

  for(i in 1:N_pat) {
    ## Get locations and time matrix for patient
    locs <- samp_info$pat_locs[[i]]
    time_ind <- samp_info$pat_time_ind[i]
    resid_vec <- as.numeric(resid_mat[locs, ])
    pat_Z <- samp_info$pat_z_kron[[i]]

    ## Patient specific covariance matrix
    if(samp_info$ar_cov) {
      pat_sig_inv <- sig_list$sig_inv_list[[time_ind]]
    } else {
      pat_sig_inv <- kronecker(sig_inv, diag(rep(1, samp_info$pat_N_obs[[i]])))
    }

    ## Cross products, covariance, alpha hat
    Z_sig_prod <- crossprod(pat_Z, pat_sig_inv)
    post_cov <- chol2inv(chol(Z_sig_prod %*% pat_Z + sig_alpha_inv))
    post_mean <- post_cov %*% Z_sig_prod %*% resid_vec
    L <- t(chol(post_cov))
    res[i, ] <- L %*% rnorm(length(post_mean)) + post_mean
  }

  ## Update Correlation matrix
  sd_mat <- diag(cur_draws$pat_sig_sd)
  pat_sig <- rinvwishart(N_pat + N_pat_eff + 1, crossprod(res) + 4 * sd_mat)

  ## Update SDs
  pat_sig_inv <- chol2inv(chol(pat_sig))
  pat_sig_sd <- 1 / LaplacesDemon::rinvgamma(
    N_pat_eff, shape = (2 + 4) / 2,
    scale = 2 * diag(pat_sig_inv) + 1 / 100000000
  )

  list(pat_effects = res,
       pat_sig = pat_sig,
       pat_sig_sd = pat_sig_sd)
}

#' Full conditional draws of the regression coefficients
#'
#' @param subject_effects matrix of patient specific intercepts
#' @param sigma residual covariance matrix
#' @param prior_alpha prior term for shape
#' @param prior_alpha prior term for scale
#' @return scalar
#' @importFrom matrixcalc is.positive.definite
#' @importFrom LaplacesDemon rinvwishart dinvwishart
#' @importFrom MBSP matrix.normal
#' @export

bmrarm_fc_sig_beta2 <- function(y, X, Z_kron, cur_draws, samp_info) {

  ## Constant
  N_outcomes <- samp_info$N_outcomes
  N_covars <- samp_info$N_covars

  ## Mean of patient effects
  mean_vec <- rowSums(Z_kron * cur_draws$pat_effects[samp_info$pat_idx_long, ])
  resid_mat <- y - matrix(mean_vec, ncol = N_outcomes)

  ## Calculate posterior covariance matrix
  cov_vals <- matrix(0, N_covars, N_covars)
  mean_vals <- matrix(0, nrow = N_covars, ncol = N_outcomes)
  resid_vals <- matrix(0, N_outcomes, N_outcomes)

  ## Sigma inverses only needed is autoregressive covariance matrix
  if(samp_info$ar_cov) {
    sig_list <- get_sig_list(cur_draws, samp_info)
  }

  for(i in 1:samp_info$N_pat) {
    ## Get locations, partial residuals after subtracting person effects
    locs <- samp_info$pat_locs[[i]]
    X_pat <- samp_info$pat_X[[i]]
    time_ind <- samp_info$pat_time_ind[i]
    if(samp_info$ar_cov) {
      ## Summation of residuals, mean values, and covariance values
      time_inv <- sig_list$time_inv[[time_ind]]
      resid_vals <- resid_vals +
        crossprod(resid_mat[locs, ], time_inv) %*% resid_mat[locs, ]
      mean_vals <- mean_vals + crossprod(X_pat, time_inv) %*% resid_mat[locs, ]
      cov_vals <- cov_vals + crossprod(X_pat, time_inv) %*% X_pat
    } else {
      ## Summation of residuals, mean values, and covariance values
      resid_vals <- resid_vals + crossprod(resid_mat[locs, ], resid_mat[locs, ])
      mean_vals <- mean_vals + crossprod(X_pat, resid_mat[locs, ])
      cov_vals <- cov_vals + crossprod(X_pat, X_pat)
    }
  }

  ## Get posterior draw
  sd_inv <- diag(1 / cur_draws$sig_sd)
  prior <- diag(rep(0.00001, N_covars))
  x_inv <- chol2inv(chol(prior + cov_vals))
  beta_hat <- x_inv %*% mean_vals
  val <- resid_vals + 4 * sd_inv - t(mean_vals) %*% beta_hat

  ## Draw updates
  sig <- rinvwishart(samp_info$N_obs + N_outcomes + 1, val)
  beta <- matrix.normal(M = beta_hat, V = sig, U = x_inv)

  ## Update SDs
  sig_inv <- chol2inv(chol(sig))
  sig_sd <- LaplacesDemon::rinvgamma(
    N_outcomes, shape = (2 + N_outcomes) / 2,
    scale = 2 * diag(sig_inv) + 1 / 10000
  )

  list(beta = beta, sig = sig, sig_sd = sig_sd)
}

#' PX-DA MCMC routine to sample from HBMRVAR model
#'
#' @param formula an object of class "formula"; a symbolic description of the model to be fitted
#' @param data a dataframe containing outcome variables, covariates, and a patient or subject identifier
#' @param ordinal_outcomes a character string containing the names of the ordinal outcomes
#' @param patient_var name of the patient or subject identifier
#' @param sig_prior prior variance on the regression coefficients
#' @param all_draws logical with a default of FALSE which discards burn-in
#' @param nsim positive integer, number of iterations with default of 1000
#' @param burn_in positive integer, number of iterations to remove with default of 100. Must be >= 100.
#' @param thin positive integer, specifiers the period of saving samples. Default of 20 due to the high autocorrelation of the cutpoints
#' @param seed positive integer, seed for random number generation
#' @param verbose logical, print iteration number to keep track of progress
#' @param max_iter_rej maximum number of rejection algorithm attempts for multivariate truncated normal
#' @return mcmc
#' @importFrom zoo na.approx
#' @importFrom fastDummies dummy_cols
#' @importFrom magic adiag
#' @export

bmr_cv <- function(formula, data, ordinal_outcome = c("y_ord"),
                   time_var = "time", patient_var = "patient_idx",
                   random_slope = F, ar_cov = TRUE, nsim = 1000,
                   burn_in = 100, thin = 10, seed = 14, verbose = TRUE,
                   sig_prior = 1000000000, sd_vec = c(0.15, 0.30)) {

  ## Long version of dataset
  X <- model.matrix.lm(as.formula(formula), data = data, na.action = "na.pass")
  out_vars <- setdiff(all.vars(formula), colnames(X))
  cont_out_var <- setdiff(out_vars, ordinal_outcome)
  data_long <- rbind(
    select(data, patient_var, time_var, val = ordinal_outcome) %>%
      mutate(outcome = 1),
    select(data, patient_var, time_var, val = cont_out_var) %>%
      mutate(outcome = 2)) %>%
    mutate(folds = NA)

  ## Max number of observations
  max_obs <- data_long %>%
    group_by(pat_idx) %>%
    summarise(N = n()) %>%
    ungroup() %>%
    select(N) %>%
    unlist() %>%
    max()

  ## Folds
  obs_responses <- which(!is.na(data_long$val))
  set.seed(seed)
  folds <- loo::kfold_split_stratified(max(max_obs, 10),
                                       data_long$pat_idx[obs_responses])

  data_long$folds[obs_responses] <- folds
  data$folds1 <- data_long$folds[1:nrow(data)]
  data$folds2 <- data_long$folds[(1:nrow(data)) + nrow(data)]
  cv_val <- 0

  for(i in 1:max(folds)) {
    data_tmp <- data
    data_tmp[data$folds1 == i & !is.na(data$folds1), ordinal_outcome] <- NA
    data_tmp[data$folds2 == i & !is.na(data$folds2), cont_out_var] <- NA
    cv_locs <- list(all_locs = which(data_long$folds == i),
                    cont_locs = which(data$folds2 == i))

    samps <- baseline_bmr(formula = formula, data = data_tmp,
                          ordinal_outcome = ordinal_outcome,
                          patient_var = patient_var,
                          random_slope = random_slope,
                          time_var = time_var, ar_cov = ar_cov,
                          burn_in = burn_in, nsim = nsim, thin = thin,
                          seed = seed,
                          sd_vec = sd_vec)

    if(!ar_cov) samps$res_ar[] <- 0
    cv_val <- c(cv_val, get_loocv_ar(samps, cv_locs,
                                     z_true = data[, ordinal_outcome],
                                     y_true = data[, cont_out_var]))
    print(i)
    print(sum(cv_val))
  }
  list(cv_vals = cv_val[-1], sum_cv_vals = sum(cv_val))
}

#' Get DIC
#'
#' @param y_current current continous outcome values
#' @param mean_vec vector of mean values
#' @param pre_calc_mat a pre-calculated matrix
#' @param ord_loc number of ordinal outcomes
#' @importFrom mvtnorm dmvnorm
#' @importFrom loo kfold_split_stratified
#' @import tidyr
#' @return scalar

strat_model_wrapper <- function(data, pat_idx, time, ord_out, cont_out) {
  ## Long version of dataset
  data_long <- rbind(
    select(data, pat_idx, time, val = ord_out) %>% mutate(outcome = 1),
    select(data, pat_idx, time, val = cont_out) %>% mutate(outcome = 2)) %>%
    mutate(folds = NA)

  ## Max number of observations
  max_obs <- data_long %>%
    group_by(pat_idx) %>%
    summarise(N = n()) %>%
    ungroup() %>%
    select(N) %>%
    unlist() %>%
    max()

  ## Folds
  obs_responses <- which(!is.na(data_long$val))

  ## Find unique folds
  correct_folds <- F
  fold_iter <- 1
  #while(fold_iter <= 100 & !correct_folds)
  folds <- loo::kfold_split_stratified(max(max_obs, 10),
                                       data_long$pat_idx[obs_responses])
  check <- data_long %>%
    group_by(pat_idx) %>%
    summarise(unique_fold = length(unique(na.omit(folds))),
              obs_responses = sum(!is.na(val)),
              correct_folds = sum(unique_fold != obs_responses)) %>%
    ungroup() %>%
    summarise(sum(correct_folds))


  data_long$folds[obs_responses] <- folds
  data$folds1 <- data_long$folds[1:nrow(data)]
  data$folds2 <- data_long$folds[(1:nrow(data)) + nrow(data)]
  cv_val <- 0

  for(i in 1:nrow(cv_vals)) {
    data_tmp <- data
    data_tmp$y_ord[data$folds1 == i] <- NA
    data_tmp$y2[data$folds2 == i] <- NA
    cv_locs <- list(all_locs = which(data_long$folds == i),
                    cont_locs = which(data$folds2 == i))

    samps <- baseline_bmr(formula = cbind(y_ord, y2) ~ time, data = data_tmp,
                          ordinal_outcome = "y_ord", patient_var = "pat_idx",
                          random_slope = T, time_var = "time", ar_cov = F,
                          burn_in = 100, nsim = 400, thin = 5, seed = 3, sd_vec = c(0.15, 0.05))
    samps$res_ar[] <- 0

    cv_val <- sum(get_loocv_ar(samps, cv_locs, z_true = data$y_ord,
                               y_true = data$y2)) + cv_val
    print(i)
    print(cv_val)
  }
  sum(cv_vals)
}

#' Full conditional draws of the latent continuous values
#'
#' @param y matrix of multivariate observations
#' @param z matrix of ordinal voutcomes
#' @param sig covariance matrix for the VAR process
#' @param sig0 for the initial values
#' @param M transition matrix for the VAR(1) component
#' @param cuts current threshold values
#' @param miss_mat locations of missing values
#' @param samp_info information for which locations to sample
#' @param num_iter current iteration number
#' @import tmvtnorm
#' @return matrix
#' @export

bmrarm_fc_patient_siw <- function(y, z, X, cur_draws, samp_info, sep_sig) {

  ## Generate full sigma matrix
  N_pat <- samp_info$N_pat
  sig_alpha_inv <- chol2inv(chol(cur_draws$pat_sig))
  sig_inv <- chol2inv(chol(cur_draws$sigma))
  resid_mat <- y - X %*% cur_draws$beta
  N_pat_eff <- ncol(samp_info$pat_z_kron[[1]])

  ## Sigma inverses only needed is autoregressive covariance matrix
  if(samp_info$ar_cov) {
    sig_list <- get_sig_list(cur_draws, samp_info)
  }

  ## Patient effects
  res <- matrix(NA, nrow = N_pat, ncol = N_pat_eff)

  for(i in 1:N_pat) {
    ## Get locations and time matrix for patient
    locs <- samp_info$pat_locs[[i]]
    time_ind <- samp_info$pat_time_ind[i]
    resid_vec <- as.numeric(resid_mat[locs, ])
    pat_Z <- samp_info$pat_z_kron[[i]]

    ## Patient specific covariance matrix
    if(samp_info$ar_cov) {
      pat_sig_inv <- sig_list$sig_inv_list[[time_ind]]
    } else {
      pat_sig_inv <- kronecker(sig_inv, diag(rep(1, samp_info$pat_N_obs[[i]])))
    }

    ## Cross products, covariance, alpha hat
    Z_sig_prod <- crossprod(pat_Z, pat_sig_inv)
    post_cov <- chol2inv(chol(Z_sig_prod %*% pat_Z + sig_alpha_inv))
    post_mean <- post_cov %*% Z_sig_prod %*% resid_vec
    L <- t(chol(post_cov))
    res[i, ] <- L %*% rnorm(length(post_mean)) + post_mean
  }

  ## Correlation matrix
  sd_inv <- diag(1 / cur_draws$pat_sig_sd)
  pat_sig_q <- rinvwishart(N_pat + N_pat_eff + 1,
                           sd_inv %*% crossprod(res) %*% sd_inv +
                             diag(rep(1, 4)))

  ## SD parameters
  accept_vec <- rep(0, N_pat_eff)
  for(i in 1:N_pat_eff) {
    ## Propose new values
    cur_draws2 <- cur_draws
    cur_draws2$pat_sig_sd[i] <- rnorm(1, cur_draws$pat_sig_sd[i], sd = samp_info$sd_pat_sd[i])
    cur_draws2$pat_sig <- diag(cur_draws2$pat_sig_sd) %*% pat_sig_q %*% diag(cur_draws2$pat_sig_sd)

    ## Calculate comparison values
    pat_inv_old <- chol2inv(chol(cur_draws$pat_sig))
    pat_inv_new <- chol2inv(chol(cur_draws2$pat_sig))

    comp_old <- N_pat / 2 * determinant(pat_inv_old, logarithm = T)[[1]][1] -
      0.5 * sum(diag(res %*% pat_inv_old %*% t(res)))

    comp_new <- N_pat / 2 * determinant(pat_inv_new, logarithm = T)[[1]][1] -
      0.5 * sum(diag(res %*% pat_inv_new %*% t(res)))
    compar_val <- comp_new - comp_old

    if(compar_val >= log(runif(1)) & cur_draws2$pat_sig_sd[i] > 0) {
      cur_draws$pat_sig_sd[i] <- cur_draws2$pat_sig_sd[i]
      accept_vec[i] <- 1
    }
  }

  list(pat_effects = res,
       pat_sig = diag(cur_draws$pat_sig_sd) %*% pat_sig_q %*% diag(cur_draws$pat_sig_sd),
       pat_sig_sd = cur_draws$pat_sig_sd, accept_vec = accept_vec, pat_sig_q = pat_sig_q)
}

#' PX-DA MCMC routine to sample from HBMRVAR model
#'
#' @param formula an object of class "formula"; a symbolic description of the model to be fitted
#' @param data a dataframe containing outcome variables, covariates, and a patient or subject identifier
#' @param ordinal_outcomes a character string containing the names of the ordinal outcomes
#' @param patient_var name of the patient or subject identifier
#' @param sig_prior prior variance on the regression coefficients
#' @param all_draws logical with a default of FALSE which discards burn-in
#' @param nsim positive integer, number of iterations with default of 1000
#' @param burn_in positive integer, number of iterations to remove with default of 100. Must be >= 100.
#' @param thin positive integer, specifiers the period of saving samples. Default of 20 due to the high autocorrelation of the cutpoints
#' @param seed positive integer, seed for random number generation
#' @param verbose logical, print iteration number to keep track of progress
#' @param max_iter_rej maximum number of rejection algorithm attempts for multivariate truncated normal
#' @return mcmc
#' @importFrom zoo na.approx
#' @importFrom fastDummies dummy_cols
#' @importFrom magic adiag
#' @importFrom lme4 lmer VarCorr lmerControl
#' @export

baseline_bmr <- function(formula, data, ordinal_outcome = c("y_ord"),
                         time_var = "time", patient_var = "patient_idx",
                         random_slope = F, ar_cov = TRUE, nsim = 1000,
                         burn_in = 100, thin = 10, seed = 14, verbose = TRUE,
                         sig_prior = 1000000000, sd_vec = c(0.15, 0.30),
                         N_burn_trunc = 5, sep_sig = T) {

  ## Create storage
  set.seed(seed)
  bmrarm_start(env = environment())
  cont_out_var <- setdiff(out_vars, ordinal_outcome)

  ## Starting values for ordinal outcome
  y[1:N_obs, 1] <- 0.5 + res_cuts[z, 1]
  y[is.infinite(y[, 1]), 1] <- -0.5
  y[is.na(y[, 1]), 1] <- 0

  ## Starting values for continuous outcomes
  df <- data.frame(patient = samp_info$pat_idx_long, y = as.numeric(y),
                   outcome = rep(1:N_outcomes, each = N_obs)) %>%
    group_by(patient, outcome) %>%
    mutate(y_interp = na.approx(y, na.rm = FALSE),
           y_interp = ifelse(!is.na(y_interp), y_interp,
                             ifelse(row_number() == n(),
                                    lag(y_interp), lead(y_interp))))
  y <- matrix(df$y_interp, ncol = N_outcomes)
  y[is.na(y)] <- 0
  i <- 2
  samp_info$burn_in <- burn_in
  samp_info$max_iter <- 10000000

  ## Emprical bayes priors for the random effects covariance matrix
  full_data <- rbind(data, data)
  full_data$outcomes <- ifelse(1:nrow(full_data) <= nrow(data),
                               data[, ordinal_outcome], data[, cont_out_var])
  full_data$ord_out <- as.numeric(1:nrow(full_data) <= nrow(data))
  full_data$cont_out <- as.numeric(1:nrow(full_data) > nrow(data))
  full_data$variable <- ifelse(1:nrow(full_data) <= nrow(data), "ord", "cont")
  full_data <- full_data[nrow(full_data):1, ]
  full_data <- full_data[!is.na(full_data$outcomes), ]

  ## Formula for the fixed effects
  coef_string <- paste0(c("ord_out:", "cont_out:"), deparse(formula[[3]]),
                        collapse = "+")
  fixed_form <- as.formula(paste0("outcomes ~ 0 + ord_out + cont_out +",
                                  coef_string))

  ## Formula for the random effects
  if(random_slope) {
    rand_string <- paste0(c("ord_out:", "cont_out:"), time_var, collapse = "+")
    rand_form <- as.formula(paste0("outcomes ~ 0 + ord_out + cont_out +",
                                   rand_string, "|", patient_var))
  } else {
    rand_form <- as.formula(paste0("outcomes ~ 0 + ord_out + cont_out |",
                                   patient_var))
  }

  ## Fit models, resort to optim if that doesnt work
  mod <- tryCatch(expr = {
    lme(fixed_form, random = rand_form, data = full_data,
        weights = varIdent(form = ~1 | variable))
  },
  warning = function(w) {
    lme(fixed_form, random = rand_form, data = full_data,
         )
  })
  var_names <- c("ord_out", "cont_out", paste0("ord_out:", time_var),
                 paste0("cont_out:", time_var))

  lme

  as.numeric(VarCorr(mod)[, 1][var_names])
  priors <- c(as.data.frame(VarCorr(mod))[1:N_pat_effects, "vcov"],
              as.data.frame(VarCorr(cont_mod))[1:N_pat_effects, "vcov"])

  ## Pass prior matrices
  if(random_slope) {
    prior_list = list(prior_int = diag(priors[c(1, 3)]) * N_outcomes,
                      prior_slope = diag(priors[c(2, 4)]) * N_outcomes,
                      full = diag(priors) * N_outcomes)
  } else {
    prior_list = list(prior_int = diag(priors * N_outcomes))
  }

  for(i in 2:nsim) {
    samp_info$num_iter <- i

    ## Regression coefficients
    vals <- bmrarm_fc_sig_beta(y, X, Z_kron, cur_draws, samp_info)
    res_beta[, i] <- cur_draws$beta <- vals$beta
    res_sig[, i] <- cur_draws$sigma <- vals$sig

    # Autoregressive parameter
    if(samp_info$ar_cov) {
      vals <- bmrarm_mh_ar(y, X, Z_kron, cur_draws, samp_info)
      res_ar[i] <- cur_draws$ar <- vals$ar
      res_accept[i, 2] <- vals$accept
    }

    ## Subject specific effects
    vals <- bmrarm_fc_patient(y, z, X, cur_draws, samp_info, prior_list, sep_sig)
    res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
    res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects

    ## Latent values, missing values, cut points
    y_cuts <- bmrarm_fc_y_cuts(y, z, X, Z_kron, cur_draws, samp_info)
    y <-  res_y[,, i] <- y_cuts$y
    res_cuts[, i] <- cur_draws$cuts <- y_cuts$cuts
    res_accept[i, 1] <- y_cuts$accept

    ## Update missing values
    y <- res_y[,, i]<- bmrarm_fc_missing(y, z, X, Z_kron, cur_draws, samp_info)

    ## Cut points
    if(i %% 150 == 100) plot(res_cuts[4, ], type = "l")
    if(i %% 150 == 50) plot(res_ar, type = "l")
    if(i %% 150 == 0) plot(res_pat_sig[1, ], type = "l")
  }

  sim_use <- seq(burn_in + 1, nsim, by = thin)
  draws <- list(
    res_cuts = res_cuts[, sim_use],
    res_beta = res_beta[, sim_use],
    res_pat_sig = res_pat_sig[, sim_use],
    res_ar = res_ar[sim_use],
    res_sigma = res_sig[, sim_use],
    res_y = res_y[,, sim_use],
    res_pat_eff = res_pat_eff[,, sim_use],
    res_accept = res_accept[sim_use, ],
    samp_info = samp_info,
    X = X,
    Z_kron = Z_kron, z = z)
  draws
}

#' PX-DA MCMC routine to sample from HBMRVAR model
#'
#' @param formula an object of class "formula"; a symbolic description of the model to be fitted
#' @param data a dataframe containing outcome variables, covariates, and a patient or subject identifier
#' @param ordinal_outcomes a character string containing the names of the ordinal outcomes
#' @param patient_var name of the patient or subject identifier
#' @param sig_prior prior variance on the regression coefficients
#' @param all_draws logical with a default of FALSE which discards burn-in
#' @param nsim positive integer, number of iterations with default of 1000
#' @param burn_in positive integer, number of iterations to remove with default of 100. Must be >= 100.
#' @param thin positive integer, specifiers the period of saving samples. Default of 20 due to the high autocorrelation of the cutpoints
#' @param seed positive integer, seed for random number generation
#' @param verbose logical, print iteration number to keep track of progress
#' @param max_iter_rej maximum number of rejection algorithm attempts for multivariate truncated normal
#' @return mcmc
#' @importFrom zoo na.approx
#' @importFrom fastDummies dummy_cols
#' @importFrom magic adiag
#' @importFrom lme4 lmer VarCorr lmerControl
#' @export

baseline_bmr <- function(formula, data, ordinal_outcome = c("y_ord"),
                         time_var = "time", patient_var = "patient_idx",
                         random_slope = F, ar_cov = TRUE, nsim = 1000,
                         burn_in = 100, thin = 10, seed = 14, verbose = TRUE,
                         sig_prior = 1000000000, sd_vec = c(0.15, 0.30),
                         N_burn_trunc = 5, sep_sig = T) {

  ## Create storage
  set.seed(seed)
  bmrarm_start(env = environment())
  cont_out_var <- setdiff(out_vars, ordinal_outcome)

  ## Starting values for ordinal outcome
  y[1:N_obs, 1] <- 0.5 + res_cuts[z, 1]
  y[is.infinite(y[, 1]), 1] <- -0.5
  y[is.na(y[, 1]), 1] <- 0

  ## Starting values for continuous outcomes
  df <- data.frame(patient = samp_info$pat_idx_long, y = as.numeric(y),
                   outcome = rep(1:N_outcomes, each = N_obs)) %>%
    group_by(patient, outcome) %>%
    mutate(y_interp = na.approx(y, na.rm = FALSE),
           y_interp = ifelse(!is.na(y_interp), y_interp,
                             ifelse(row_number() == n(),
                                    lag(y_interp), lead(y_interp))))
  y <- matrix(df$y_interp, ncol = N_outcomes)
  y[is.na(y)] <- 0
  i <- 2
  samp_info$burn_in <- burn_in
  samp_info$max_iter <- 10000000

  ## Emprical bayes priors for the random effects covariance matrix
  if(random_slope) {
    form_string <- paste0("~ . + (", time_var, " |", patient_var, ")")
  } else {
    form_string <- paste0("~ . + (1|", patient_var, ")")
  }
  form_use <- update(formula, as.formula(form_string))
  ord_form <- reformulate(deparse(form_use[[3]]), response = ordinal_outcome)
  cont_form <- reformulate(deparse(form_use[[3]]), response = cont_out_var)

  ## Fit models, default to nelder_mead if optimization doesn't work
  ord_mod <- tryCatch(expr = {
    lmer(ord_form, data = data)
  },
  warning = function(w) {
    lmer(ord_form, data = data, REML = T,
         control = lmerControl(optimizer ="Nelder_Mead"))
  })
  cont_mod <- tryCatch(expr = {
    lmer(cont_form, data = data)
  },
  warning = function(w) {
    lmer(cont_form, data = data, REML = T,
         control = lmerControl(optimizer ="Nelder_Mead"))
  })
  priors <- c(as.data.frame(VarCorr(ord_mod))[1:N_pat_effects, "vcov"],
              as.data.frame(VarCorr(cont_mod))[1:N_pat_effects, "vcov"])

  ## Pass prior matrices
  if(random_slope) {
    prior_list = list(prior_int = diag(priors[c(1, 3)]) * N_outcomes,
                      prior_slope = diag(priors[c(2, 4)]) * N_outcomes,
                      full = diag(priors) * N_outcomes)
  } else {
    prior_list = list(prior_int = diag(priors * N_outcomes))
  }

  for(i in 2:nsim) {
    samp_info$num_iter <- i

    ## Regression coefficients
    vals <- bmrarm_fc_sig_beta(y, X, Z_kron, cur_draws, samp_info)
    res_beta[, i] <- cur_draws$beta <- vals$beta
    res_sig[, i] <- cur_draws$sigma <- vals$sig

    # Autoregressive parameter
    if(samp_info$ar_cov) {
      vals <- bmrarm_mh_ar(y, X, Z_kron, cur_draws, samp_info)
      res_ar[i] <- cur_draws$ar <- vals$ar
      res_accept[i, 2] <- vals$accept
    }

    ## Subject specific effects
    vals <- bmrarm_fc_patient(y, z, X, cur_draws, samp_info, prior_list, sep_sig)
    res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
    res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects

    ## Latent values, missing values, cut points
    y_cuts <- bmrarm_fc_y_cuts(y, z, X, Z_kron, cur_draws, samp_info)
    y <-  res_y[,, i] <- y_cuts$y
    res_cuts[, i] <- cur_draws$cuts <- y_cuts$cuts
    res_accept[i, 1] <- y_cuts$accept

    ## Update missing values
    y <- res_y[,, i]<- bmrarm_fc_missing(y, z, X, Z_kron, cur_draws, samp_info)

    ## Cut points
    if(i %% 150 == 100) plot(res_cuts[4, ], type = "l")
    if(i %% 150 == 50) plot(res_ar, type = "l")
    if(i %% 150 == 0) plot(res_pat_sig[1, ], type = "l")
  }

  sim_use <- seq(burn_in + 1, nsim, by = thin)
  draws <- list(
    res_cuts = res_cuts[, sim_use],
    res_beta = res_beta[, sim_use],
    res_pat_sig = res_pat_sig[, sim_use],
    res_ar = res_ar[sim_use],
    res_sigma = res_sig[, sim_use],
    res_y = res_y[,, sim_use],
    res_pat_eff = res_pat_eff[,, sim_use],
    res_accept = res_accept[sim_use, ],
    samp_info = samp_info,
    X = X,
    Z_kron = Z_kron, z = z)
  draws
}


#' Full conditional draws of the latent continuous values
#'
#' @param y matrix of multivariate observations
#' @param z matrix of ordinal voutcomes
#' @param sig covariance matrix for the VAR process
#' @param sig0 for the initial values
#' @param M transition matrix for the VAR(1) component
#' @param cuts current threshold values
#' @param miss_mat locations of missing values
#' @param samp_info information for which locations to sample
#' @param num_iter current iteration number
#' @import tmvtnorm
#' @return matrix
#' @export

bmrarm_fc_patient_siw <- function(y, z, X, cur_draws, samp_info, sep_sig) {

  ## Generate full sigma matrix
  N_pat <- samp_info$N_pat
  sig_alpha_inv <- chol2inv(chol(cur_draws$pat_sig))
  sig_inv <- chol2inv(chol(cur_draws$sigma))
  resid_mat <- y - X %*% cur_draws$beta
  N_pat_eff <- ncol(samp_info$pat_z_kron[[1]])

  ## Sigma inverses only needed is autoregressive covariance matrix
  if(samp_info$ar_cov) {
    sig_list <- get_sig_list(cur_draws, samp_info)
  }

  ## Patient effects
  res <- matrix(NA, nrow = N_pat, ncol = N_pat_eff)

  for(i in 1:N_pat) {
    ## Get locations and time matrix for patient
    locs <- samp_info$pat_locs[[i]]
    time_ind <- samp_info$pat_time_ind[i]
    resid_vec <- as.numeric(resid_mat[locs, ])
    pat_Z <- samp_info$pat_z_kron[[i]]

    ## Patient specific covariance matrix
    if(samp_info$ar_cov) {
      pat_sig_inv <- sig_list$sig_inv_list[[time_ind]]
    } else {
      pat_sig_inv <- kronecker(sig_inv, diag(rep(1, samp_info$pat_N_obs[[i]])))
    }

    ## Cross products, covariance, alpha hat
    Z_sig_prod <- crossprod(pat_Z, pat_sig_inv)
    post_cov <- chol2inv(chol(Z_sig_prod %*% pat_Z + sig_alpha_inv))
    post_mean <- post_cov %*% Z_sig_prod %*% resid_vec
    L <- t(chol(post_cov))
    res[i, ] <- L %*% rnorm(length(post_mean)) + post_mean
  }

  ## Correlation matrix
  sd_inv <- diag(1 / cur_draws$pat_sig_sd)
  pat_sig_q <- rinvwishart(N_pat + N_pat_eff + 1,
                           sd_inv %*% crossprod(res) %*% sd_inv +
                             diag(N_pat_eff))

  # ## SD parameters
  accept_vec <- rep(0, N_pat_eff)
  for(i in 1:N_pat_eff) {
    ## Propose new values
    cur_draws2 <- cur_draws
    #cur_draws2$pat_sig_sd[i] <- exp(rnorm(1, log(cur_draws$pat_sig_sd[i]), sd = samp_info$sd_pat_sd[i]))
    cur_draws2$pat_sig_sd[i] <- rtruncnorm(1, a = 0, b = Inf, mean = cur_draws$pat_sig_sd[i], sd = samp_info$sd_pat_sd[i])
    cur_draws2$pat_sig <- diag(cur_draws2$pat_sig_sd) %*% pat_sig_q %*% diag(cur_draws2$pat_sig_sd)

    ## Calculate comparison values
    pat_inv_old <- chol2inv(chol(cur_draws$pat_sig))
    pat_inv_new <- chol2inv(chol(cur_draws2$pat_sig))

    comp_old <- N_pat / 2 * determinant(pat_inv_old, logarithm = T)[[1]][1] -
      0.5 * sum(diag(res %*% pat_inv_old %*% t(res)))

    comp_new <- N_pat / 2 * determinant(pat_inv_new, logarithm = T)[[1]][1] -
      0.5 * sum(diag(res %*% pat_inv_new %*% t(res)))
    compar_val <- comp_new - comp_old +
      log(truncnorm::dtruncnorm(cur_draws$pat_sig_sd[i], 0, Inf,
                                mean = cur_draws2$pat_sig_sd[i],
                                sd = samp_info$sd_pat_sd[i])) -
      log(truncnorm::dtruncnorm(cur_draws2$pat_sig_sd[i], 0, Inf,
                                mean = cur_draws$pat_sig_sd[i],
                                sd = samp_info$sd_pat_sd[i]))

    if(compar_val >= log(runif(1)) & cur_draws2$pat_sig_sd[i] > 0) {
      cur_draws$pat_sig_sd[i] <- cur_draws2$pat_sig_sd[i]
      accept_vec[i] <- 1
    }
  }
  ## SD parameters
  # accept_vec <- rep(0, N_pat_eff)
  #
  # ## Propose new values
  # cur_draws2 <- cur_draws
  # cur_draws2$pat_sig_sd <- rnorm(length(cur_draws$pat_sig_sd), cur_draws$pat_sig_sd, sd = samp_info$sd_pat_sd[1])
  # cur_draws2$pat_sig <- diag(cur_draws2$pat_sig_sd) %*% pat_sig_q %*% diag(cur_draws2$pat_sig_sd)
  #
  # ## Calculate comparison values
  # pat_inv_old <- chol2inv(chol(cur_draws$pat_sig))
  # pat_inv_new <- chol2inv(chol(cur_draws2$pat_sig))
  #
  # comp_old <- N_pat / 2 * determinant(pat_inv_old, logarithm = T)[[1]][1] -
  #   0.5 * sum(diag(res %*% pat_inv_old %*% t(res)))
  #
  # comp_new <- N_pat / 2 * determinant(pat_inv_new, logarithm = T)[[1]][1] -
  #   0.5 * sum(diag(res %*% pat_inv_new %*% t(res)))
  # compar_val <- comp_new - comp_old
  #
  # if(compar_val >= log(runif(1)) & min(cur_draws2$pat_sig_sd) > 0) {
  #   cur_draws$pat_sig_sd <- cur_draws2$pat_sig_sd
  #   accept_vec[1] <- 1
  # }

  list(pat_effects = res,
       pat_sig = diag(cur_draws$pat_sig_sd) %*% pat_sig_q %*% diag(cur_draws$pat_sig_sd),
       pat_sig_sd = cur_draws$pat_sig_sd, accept_vec = accept_vec, pat_sig_q = pat_sig_q)
}

#' Full conditional draws of the latent continuous values
#'
#' @param y matrix of multivariate observations
#' @param z matrix of ordinal voutcomes
#' @param sig covariance matrix for the VAR process
#' @param sig0 for the initial values
#' @param M transition matrix for the VAR(1) component
#' @param cuts current threshold values
#' @param miss_mat locations of missing values
#' @param samp_info information for which locations to sample
#' @param num_iter current iteration number
#' @import tmvtnorm
#' @return matrix
#' @export

bmrarm_fc_patient_simp <- function(y, z, X, cur_draws, samp_info, sep_sig) {

  ## Generate full sigma matrix
  N_pat <- samp_info$N_pat
  sig_alpha_inv <- chol2inv(chol(cur_draws$pat_sig))
  sig_inv <- chol2inv(chol(cur_draws$sigma))
  resid_mat <- y - X %*% cur_draws$beta
  N_pat_eff <- ncol(samp_info$pat_z_kron[[1]])

  ## Sigma inverses only needed is autoregressive covariance matrix
  if(samp_info$ar_cov) {
    sig_list <- get_sig_list(cur_draws, samp_info)
  }

  ## Patient effects
  res <- matrix(NA, nrow = N_pat, ncol = N_pat_eff)

  for(i in 1:N_pat) {
    ## Get locations and time matrix for patient
    locs <- samp_info$pat_locs[[i]]
    time_ind <- samp_info$pat_time_ind[i]
    resid_vec <- as.numeric(resid_mat[locs, ])
    pat_Z <- samp_info$pat_z_kron[[i]]

    ## Patient specific covariance matrix
    if(samp_info$ar_cov) {
      pat_sig_inv <- sig_list$sig_inv_list[[time_ind]]
    } else {
      pat_sig_inv <- kronecker(sig_inv, diag(rep(1, samp_info$pat_N_obs[[i]])))
    }

    ## Cross products, covariance, alpha hat
    Z_sig_prod <- crossprod(pat_Z, pat_sig_inv)
    post_cov <- chol2inv(chol(Z_sig_prod %*% pat_Z + sig_alpha_inv))
    post_mean <- post_cov %*% Z_sig_prod %*% resid_vec
    L <- t(chol(post_cov))
    res[i, ] <- L %*% rnorm(length(post_mean)) + post_mean
  }

  ## Update Correlation matrix
  sd_mat <- diag(cur_draws$pat_sig_sd)
  pat_sig <- rinvwishart(N_pat + N_pat_eff + 1, crossprod(res) + 4 * sd_mat)

  ## Update SDs
  pat_sig_inv <- chol2inv(chol(pat_sig))
  pat_sig_sd <- 1 / LaplacesDemon::rinvgamma(
    N_pat_eff, shape = (2 + N_pat_eff) / 2,
    scale = 2 * diag(pat_sig_inv) + 1 / 100000000
  )

  list(pat_effects = res,
       pat_sig = pat_sig,
       pat_sig_sd = pat_sig_sd)
}

#' Full conditional draws of the regression coefficients
#'
#' @param subject_effects matrix of patient specific intercepts
#' @param sigma residual covariance matrix
#' @param prior_alpha prior term for shape
#' @param prior_alpha prior term for scale
#' @importFrom LaplacesDemon rinvwishart rmatrixnorm
#' @export

bmrarm_fc_sig_beta_px <- function(y, X, Z_kron, cur_draws, samp_info) {

  ## Constant
  N_outcomes <- samp_info$N_outcomes
  N_covars <- samp_info$N_covars

  ## Mean of patient effects
  mean_vec <- rowSums(Z_kron * cur_draws$pat_effects[samp_info$pat_idx_long, ])
  resid_mat <- y - matrix(mean_vec, ncol = N_outcomes)

  ## Calculate posterior covariance matrix
  cov_vals <- matrix(0, N_covars, N_covars)
  mean_vals <- matrix(0, nrow = N_covars, ncol = N_outcomes)
  resid_vals <- matrix(0, N_outcomes, N_outcomes)

  ## Sigma inverses only needed is autoregressive covariance matrix
  if(samp_info$ar_cov) {
    sig_list <- get_sig_list(cur_draws, samp_info)
  }

  for(i in 1:samp_info$N_pat) {
    ## Get locations, partial residuals after subtracting person effects
    locs <- samp_info$pat_locs[[i]]
    X_pat <- samp_info$pat_X[[i]]
    time_ind <- samp_info$pat_time_ind[i]
    if(samp_info$ar_cov) {
      ## Summation of residuals, mean values, and covariance values
      time_inv <- sig_list$time_inv[[time_ind]]
      resid_vals <- resid_vals +
        crossprod(resid_mat[locs, ], time_inv) %*% resid_mat[locs, ]
      mean_vals <- mean_vals + crossprod(X_pat, time_inv) %*% resid_mat[locs, ]
      cov_vals <- cov_vals + crossprod(X_pat, time_inv) %*% X_pat
    } else {
      ## Summation of residuals, mean values, and covariance values
      resid_vals <- resid_vals + crossprod(resid_mat[locs, ], resid_mat[locs, ])
      mean_vals <- mean_vals + crossprod(X_pat, resid_mat[locs, ])
      cov_vals <- cov_vals + crossprod(X_pat, X_pat)
    }
  }

  ## Get posterior draw
  prior <- diag(rep(0.00001, N_covars))
  x_inv <- chol2inv(chol(prior + cov_vals))
  beta_hat <- x_inv %*% mean_vals
  val <- resid_vals + diag(rep(1, N_outcomes)) - t(mean_vals) %*% beta_hat

  ## Draw updates
  sig <- rinvwishart(samp_info$N_obs + N_outcomes, val)
  beta <- rmatrixnorm(M = beta_hat, V = cur_draws$sigma, U = x_inv)
  beta
}


#' Generate data for longitudinal simulation
#'
#' @param N Mean time points per patient, drawn from a poisson
#' @param N_pat number of patients
#' @param seed seed to set, default of 10
#' @importFrom MASS mvrnorm
#' @import ggplot2
#' @import dplyr
#' @importFrom magic adiag

gen_ar_errors_px <- function(N = 7, N_pat = 48, seed = 10, unequal = FALSE,
                             slope = F, ar_cov = T) {
  set.seed(seed)

  ## Number of observations
  if(unequal) {
    obs_counts <- sample((N - 3):N, size = N_pat, replace = T,
                         prob = c(0.042, 0.042, 0.083, 0.833))
  } else {
    obs_counts <- rep(N, N_pat)
  }
  pat_idx <- rep(1:length(obs_counts), times = obs_counts)
  pat_idx <- c(pat_idx, pat_idx)
  N_total <- sum(obs_counts)

  ## Additional effects
  for(i in 1:length(obs_counts)) {
    if(i == 1) {
      time_covar <- 0:(obs_counts[i] - 1)
    } else {
      time_covar <- c(time_covar, 0:(obs_counts[i] - 1))
    }
  }
  cov_mat <- cbind(1, time_covar)
  cov_df <- as.data.frame(cov_mat)
  colnames(cov_df) <- c("intercept", "time")

  beta <- c(0.5, 0.18, 0.05, 0.1)
  sigma <- matrix(c(1, 0.025,
                    0.025, 0.13), ncol = 2, byrow = T)

  subject_effects <- subj_slopes <- matrix(NA, ncol = 2, nrow = N_pat)

  sig_alpha <- matrix(c(0.22, 0.075,
                        0.075, 0.18), ncol = 2, byrow = TRUE)
  slope_alpha <- matrix(c(0.05, 0.005, 0.005, 0.04), ncol = 2)
  for(i in 1:N_pat) {
    subject_effects[i, ] <- mvrnorm(1, mu = rep(0, 2), Sigma = sig_alpha)
    subj_slopes[i, ] <- mvrnorm(1, mu = rep(0, 2), Sigma = slope_alpha)
  }

  ## Subject and time indexing
  ar_val <- c(0.35)
  y <- true_means <- err_vec <- fixed_means <- rep(NA, N_total * 2)
  kron_X <- kronecker(diag(rep(1, 2)), cov_mat)

  if(slope) {
    kron_Z <- kron_X
    subject_effects <- cbind(subject_effects[, 1], subj_slopes[, 1],
                             subject_effects[, 2], subj_slopes[, 2])
  } else {
    kron_Z <- kron_X[, c(1, 3)]
  }

  cur_draws <- list(sigma = sigma, ar = ar_val)

  for(i in 1:N_pat) {
    locs <- which(pat_idx == i)
    dist_mat <- as.matrix(dist(1:(length(locs) / 2), diag = T, upper = T))
    if(ar_cov) {
      dist_mat2 <- exp(-ar_val * dist_mat)
      dist_mat2 <- ar_val ^ dist_mat
    } else {
      dist_mat2 <- diag(1, length(locs) / 2)
    }
    sig_full <- kronecker(sigma, dist_mat2)
    num_locs <- length(locs)
    fixed_means[locs] <- kron_X[locs, ] %*% beta
    true_means[locs] <- kron_X[locs, ] %*% beta + kron_Z[locs, ] %*% subject_effects[i, ]
    #mean_no_int[locs] <- kron_X[locs, ] %*% beta + kron_Z[locs, c(2, 4)] %*% subject_effects[i, c(2, 4)]
    err_vec[locs] <- MASS::mvrnorm(1, mu = rep(0, length(locs)), Sigma = sig_full)
    y[locs] <- true_means[locs] + err_vec[locs]
  }
  #inv <- solve(t(kron_Z[locs, ]) %*% solve(sig_full) %*% kron_Z[locs, ])
  #inv %*% t(kron_Z[locs, ]) %*% solve(sig_full) %*% (y[locs] - fixed_means[locs])

  ## Create ordinal values and binary values
  full <- data.frame(pat_idx, y, outcome = rep(c(1, 2), each = N_total)) %>%
    group_by(pat_idx, outcome) %>%
    mutate(obs_num = row_number() - 1)
  ggplot(full, aes(y, x = obs_num, col = pat_idx, group = pat_idx)) +
    geom_line() +
    facet_wrap(.~outcome)
  cuts <- c(-Inf, 0, 1, 1.5, 1.9, Inf)
  full$y_ord <- case_when(
    full$y <= cuts[2] ~ 1,
    full$y <= cuts[3] ~ 2,
    full$y <= cuts[4] ~ 3,
    full$y <= cuts[5]  ~ 4,
    full$y > cuts[5]  ~ 5
  )

  ## Check for reasonable counts
  table(full$y_ord)

  ## Build dataframe
  N_obs <- sum(full$outcome == 1)

  df <- data.frame(y1 = full$y[full$outcome == 1],
                   y_ord = full$y_ord[full$outcome == 1],
                   y2 = full$y[full$outcome == 2],
                   pat_idx = full$pat_idx[full$outcome == 1],
                   time = full$obs_num[full$outcome == 1])

  if(slope) {
    sig_alpha <- magic::adiag(sig_alpha, slope_alpha)
    sig_alpha <- sig_alpha[c(1, 3, 2, 4), c(1, 3, 2, 4)]
  }

  ## Include missing values
  truth <- df
  df[df$time == 2, c("y_ord")] <- NA
  df$y_ord[sample(which(df$time > 2), size = 4)] <- NA
  df$y2[sample(1:nrow(df), size = 9)] <- NA

  list(data = df, sigma_full = sig_full, sigma = sigma,
       beta = beta, cuts = cuts, X = cov_mat, alpha = subject_effects,
       sig_alpha = sig_alpha, true_means = true_means, fixed_means = fixed_means,
       truth = truth, ar = ar_val, err_vec = err_vec)
}



#' Full conditional draws of the latent continuous values
#'
#' @param y matrix of multivariate observations
#' @param z matrix of ordinal voutcomes
#' @param sig covariance matrix for the VAR process
#' @param sig0 for the initial values
#' @param M transition matrix for the VAR(1) component
#' @param cuts current threshold values
#' @param miss_mat locations of missing values
#' @param samp_info information for which locations to sample
#' @param num_iter current iteration number
#' @import tmvtnorm
#' @importFrom truncnorm rtruncnorm
#' @importFrom OpenMx omxMnor
#' @return matrix
#' @export

bmrarm_fc_y_cuts_px <- function(y, z, X, Z_kron, cur_draws, samp_info) {

  ## Mean matrix
  mean_mat <- X %*% cur_draws$beta +
    matrix(rowSums(Z_kron * cur_draws$pat_effects[samp_info$pat_idx_long, ]),
           ncol = samp_info$N_outcomes)

  ## Generate full sigma matrix
  cuts <- cur_draws$cuts
  N_pat <- samp_info$N_pat
  N_cat <- samp_info$N_cat
  N_cuts <- N_cat + 1
  cuts_tmp <- cuts

  ## Calculate conditional mean for each subject
  cond_mean <- rep(NA, samp_info$N_obs)
  if(samp_info$ar_cov) {
    sig_list <- get_sig_list(cur_draws, samp_info)
    for(i in 1:N_pat) {
      ## Locations of vectors to sample
      locs <- samp_info$pat_locs[[i]]
      ind <- samp_info$pat_time_ind[i]
      cond_mean[locs] <- as.numeric(
        mean_mat[locs, 1] + sig_list$mean_pre_list[[ind]] %*%
          (as.numeric(y[locs, -1]) - as.numeric(mean_mat[locs, -1])))
    }
  } else {
    ## Conditional means and covariances
    sig <- cur_draws$sigma
    pre_calcs <- pre_calc_ar(sig, 1)
    cond_sd <- sqrt(as.numeric(pre_calcs$cond_cov))
    cond_mean <- mean_mat[, 1] + as.numeric(pre_calcs$mean_pre) *
      (as.numeric(y[, -1]) - as.numeric(mean_mat[, -1]))
  }

  # Update cutpoints --------------------------------------------------------

  if(N_cat > 2) {
    sd_c <- samp_info$sd_c
    cuts_vec <- c(-Inf, 0, rep(NA, N_cat - 2), Inf)
    ## Only update if more than 3 levels
    if(N_cat >= 3) {
      for(i in 3:N_cat) {
        cuts_min <- max(y[which(z == (i - 1))])
        cuts_max <- min(y[which(z == i)])
        cuts_vec[i] <- runif(1, cuts_min, cuts_max)
      }
    }
    cuts_tmp <- cuts_vec

    ## Storage of thresholds
    cuts_low <- cuts_tmp[z]
    cuts_high <- cuts_tmp[z + 1]
    cuts_low[is.na(cuts_low)] <- -Inf
    cuts_high[is.na(cuts_high)] <- Inf
  } else {
    cuts_low <- cuts_tmp[z]
    cuts_high <- cuts_tmp[z + 1]
    cuts_low[is.na(cuts_low)] <- -Inf
    cuts_high[is.na(cuts_high)] <- Inf
  }

  # Update latent values ----------------------------------------------------

  if(samp_info$ar_cov) {
    for(i in 1:N_pat) {
      ## Locations of vectors to sample
      locs <- samp_info$pat_locs[[i]]
      ind <- samp_info$pat_time_ind[i]

      ## Sample from multivariate truncated normal
      start_val <- pmax(pmin(cond_mean[locs], cuts_high[locs]), cuts_low[locs])
      y[locs, 1] <- rtmvnorm(
        1, mean = cond_mean[locs], H = sig_list$cond_cov_inv_list[[ind]],
        lower = cuts_low[locs], upper = cuts_high[locs], algorithm = "gibbs",
        burn.in.samples = 10, start.value = start_val)
    }
  } else {
    N_obs <- length(z)
    y[1:N_obs, 1] <- rtruncnorm(N_obs, a = cuts_low, b = cuts_high,
                                mean = cond_mean, sd = cond_sd)
  }
  list(y = y, cuts = cuts_tmp, accept = 1)
}

#' PX-DA MCMC routine to sample from HBMRVAR model
#'
#' @param formula an object of class "formula"; a symbolic description of the model to be fitted
#' @param data a dataframe containing outcome variables, covariates, and a patient or subject identifier
#' @param ordinal_outcomes a character string containing the names of the ordinal outcomes
#' @param patient_var name of the patient or subject identifier
#' @param sig_prior prior variance on the regression coefficients
#' @param all_draws logical with a default of FALSE which discards burn-in
#' @param nsim positive integer, number of iterations with default of 1000
#' @param burn_in positive integer, number of iterations to remove with default of 100. Must be >= 100.
#' @param thin positive integer, specifiers the period of saving samples. Default of 20 due to the high autocorrelation of the cutpoints
#' @param seed positive integer, seed for random number generation
#' @param verbose logical, print iteration number to keep track of progress
#' @param max_iter_rej maximum number of rejection algorithm attempts for multivariate truncated normal
#' @return mcmc
#' @importFrom zoo na.approx
#' @importFrom fastDummies dummy_cols
#' @importFrom magic adiag
#' @importFrom nlme lme VarCorr lmeControl corAR1
#' @export

baseline_bmr_px <- function(formula, data, ordinal_outcome = c("y_ord"),
                            time_var = "time", patient_var = "patient_idx",
                            random_slope = F, ar_cov = TRUE, nsim = 1000,
                            burn_in = 100, thin = 10, seed = 14, verbose = TRUE,
                            sig_prior = 1000000000, sd_vec = c(0.15, 0.30),
                            N_burn_trunc = 5, prior_siw_uni = c(0.5, 2)) {

  ## Create storage
  set.seed(seed)
  bmrarm_start(env = environment())
  cont_out_var <- setdiff(out_vars, ordinal_outcome)

  ## Starting values for ordinal outcome
  y[1:N_obs, 1] <- 0.5 + res_cuts[z, 1]
  y[is.infinite(y[, 1]), 1] <- -0.5
  y[is.na(y[, 1]), 1] <- 0

  ## Starting values for continuous outcomes
  df <- data.frame(patient = samp_info$pat_idx_long, y = as.numeric(y),
                   outcome = rep(1:N_outcomes, each = N_obs)) %>%
    group_by(patient, outcome) %>%
    mutate(y_interp = na.approx(y, na.rm = FALSE),
           y_interp = ifelse(!is.na(y_interp), y_interp,
                             ifelse(row_number() == n(),
                                    lag(y_interp), lead(y_interp))))
  y <- matrix(df$y_interp, ncol = N_outcomes)
  y[is.na(y)] <- 0
  i <- 2
  samp_info$burn_in <- burn_in
  samp_info$max_iter <- 10000000

  ## Emprical bayes priors for the random effects covariance matrix
  if(random_slope) {
    rand_form <- as.formula(paste0("~ ", time_var, "|", patient_var))
  } else {
    rand_form <- as.formula(paste0("~ 1|", patient_var))
  }

  ord_form <- reformulate(deparse(formula[[3]]), response = ordinal_outcome)
  cont_form <- reformulate(deparse(formula[[3]]), response = cont_out_var)

  ## Datasets and structures for models
  data_ord <- data[!is.na(data[, ordinal_outcome]), ]
  data_cont <- data[!is.na(data[, cont_out_var]), ]
  cor_struct <- if(ar_cov) {
    cor_struct <- corAR1(form = as.formula(~ 1 | pat_idx))
    #cor_struct <- NULL
  } else {
    cor_struct <- NULL
  }

  ## Fit ordinal model
  ord_mod <- tryCatch(expr = {
    lme(ord_form, data = data_ord, random = rand_form, correlation = cor_struct)
  },
  error = function(e) {
    tryCatch(expr = {
      lme(ord_form, data = data_ord, random = rand_form,
          correlation = cor_struct, control = lmeControl(opt='optim'))
    },
    error = function(e) {
      ## Resort to no AR structure
      lme(ord_form, data = data_ord, random = rand_form,
          control = lmeControl(opt='optim'))
    })
  })

  ## Fit continuous model
  cont_mod <- tryCatch(expr = {
    lme(cont_form, data = data_cont, random = rand_form,
        correlation = cor_struct)
  },
  error = function(e) {
    tryCatch(expr = {
      lme(cont_form, data = data_cont, random = rand_form,
          correlation = cor_struct, control = lmeControl(opt='optim'))
    },
    ## Resort to no AR structure
    error = function(w) {
      ## Resort to no AR structure
      lme(cont_form, data = data_cont, random = rand_form,
          control = lmeControl(opt='optim'))
    })
  })

  ## Pass prior matrices
  priors <- as.numeric(c(VarCorr(ord_mod)[, 1][1:N_pat_effects],
                         VarCorr(cont_mod)[, 1][1:N_pat_effects]))
  prior_mat <- diag(priors)
  res_accept <- matrix(NA, nsim, 6)
  cor_mat <- diag(1, 2)

  for(i in 2:nsim) {
    samp_info$num_iter <- i

    ## Latent values, missing values, cut points
    y_cuts <- bmrarm_fc_y_cuts_px(y, z, X, Z_kron, cur_draws, samp_info)
    y <-  res_y[,, i] <- y_cuts$y
    res_cuts[, i] <- cur_draws$cuts <- y_cuts$cuts
    res_accept[i, 1] <- y_cuts$accept

    ## Update missing values
    y <- res_y[,, i]<- bmrarm_fc_missing(y, z, X, Z_kron, cur_draws, samp_info)

    ## Regression coefficients
    ex_prior <- expansion_prior(cor_mat, N_ordinal = 1)
    resid <- y - X %*% cur_draws$beta -
      matrix(rowSums(Z_kron * cur_draws$pat_effects[samp_info$pat_idx_long, ]),
             ncol = samp_info$N_outcomes)
    resid_tilde <- resid %*% ex_prior
    sig_tilde <- rinvwishart(nrow(resid) + 3, crossprod(resid_tilde) + diag(rep(1, 2)))
    diag_vals <- sqrt(sig_tilde[1, 1])
    v_half <- diag(c(diag_vals, rep(1, 1)))
    v_half_inv <- diag(1 / diag(v_half))
    res_sig[, i] <- cor_mat <- cur_draws$sigma <- v_half_inv %*% sig_tilde %*% v_half_inv

    y2 <- resid_tilde %*% v_half_inv + X %*% cur_draws$beta +
      matrix(rowSums(Z_kron * cur_draws$pat_effects[samp_info$pat_idx_long, ]),
             ncol = samp_info$N_outcomes)

    res_beta[, i] <- cur_draws$beta <- bmrarm_fc_sig_beta_px(y, X, Z_kron, cur_draws, samp_info)
    max(y[, 1][which(z == 1)])
    min(y[, 1][which(z == 2)])

    max(y2[, 1][which(z == 1)])
    min(y2[, 1][which(z == 2)])

    max(y2[, 1][which(z == 2)])
    min(y2[, 1][which(z == 3)])

    max(y2[, 1][which(z == 3)])
    min(y2[, 1][which(z == 4)])


    # Autoregressive parameter
    if(samp_info$ar_cov) {
      vals <- bmrarm_mh_ar(y, X, Z_kron, cur_draws, samp_info)
      cur_draws$ar <- vals$ar
      res_accept[i, 2] <- vals$accept
    }
    res_ar[i] <- cur_draws$ar

    ## Subject specific effects
    # vals <- bmrarm_fc_patient(y, z, X, cur_draws, samp_info, prior_mat)
    # res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
    # res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects

    vals <- bmrarm_fc_patient_siw(y, z, X, cur_draws, samp_info, 1, Z_kron, prior_siw_uni)
    res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
    res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects
    res_pat_sig_q[,i] <- cur_draws$pat_sig_q <- vals$pat_sig_q
    res_pat_sig_sd[,i] <- cur_draws$pat_sig_sd <- vals$pat_sig_sd
    res_accept[i, 3:6] <- vals$accept_vec

    ## Cut points
    #if(i %% 150 == 100) plot(res_cuts[4, ], type = "l")
    #if(i %% 150 == 100) plot(res_pat_sig_sd[1, ], type = "l")
    if(i %% 150 == 50 & i > burn_in) print(round(c(colMeans(res_accept[(burn_in+1):nsim,], na.rm = T), i), 3))
    if(i %% 150 == 0) plot(res_pat_sig[1, ], type = "l")
    #plot(res_pat_sig[11, ] / res_sig[1, ], type = "l")
    #plot(res_cuts[3, ] / sqrt(res_sig[1, ]), type = "l")
    #plot(res_cuts[4, ] / sqrt(res_sig[1, ]), type = "l")
  }

  sim_use <- seq(burn_in + 1, nsim, by = thin)
  draws <- list(
    res_cuts = res_cuts[, sim_use],
    res_beta = res_beta[, sim_use],
    res_pat_sig = res_pat_sig[, sim_use],
    res_pat_sig_q = res_pat_sig_q[, sim_use],
    res_pat_sig_sd = res_pat_sig_sd[, sim_use],
    res_ar = res_ar[sim_use],
    res_sigma = res_sig[, sim_use],
    res_y = res_y[,, sim_use],
    res_pat_eff = res_pat_eff[,, sim_use],
    res_accept = res_accept[sim_use, ],
    samp_info = samp_info,
    X = X,
    Z_kron = Z_kron, z = z,
    priors = priors)
  draws
}
