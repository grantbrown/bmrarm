## Create storage
set.seed(seed)
bmrarm_start(env = environment())
cont_out_var <- setdiff(out_vars, ordinal_outcome)

## Starting values for ordinal outcome
y[, 1] <- (res_cuts[z, 1] + res_cuts[z + 1, 1]) / 2
y[is.infinite(y[, 1]) & y[, 1] < 0, 1] <- -0.5
y[is.infinite(y[, 1]) & y[, 1] > 0, 1] <-
  max(cur_draws$cuts[samp_info$N_cat]) + 0.5
y[is.na(y[, 1]), 1] <- 0

## Starting values for continuous outcomes
df <- data.frame(patient = samp_info$pat_idx_long, y = as.numeric(y),
                 outcome = rep(1:N_outcomes, each = N_obs)) %>%
  group_by(patient, outcome) %>%
  mutate(y_interp = na.approx(y, na.rm = FALSE),
         y_interp = ifelse(!is.na(y_interp), y_interp,
                           ifelse(row_number() == n(),
                                  lag(y_interp), lead(y_interp))))
y <- matrix(df$y_interp, ncol = N_outcomes)
y[is.na(y)] <- 0
i <- 2
samp_info$burn_in <- burn_in
samp_info$max_iter <- 10000000

#' Create list of covariance matrices and optionally their inverse
#'
#' @param env parent environment

get_sig_list2 <- function(cur_draws, samp_info) {
  chol_list <- marg_cov_list <- sig_list <- sig_inv_list <-
    cond_cov_inv_list <- mean_pre_list <- cond_cov_list <- time_inv <-
    time_det <- list()
  sigma <- cur_draws$sigma
  inv_sigma <- chol2inv(chol(sigma))
  sig_alpha_inv <- chol2inv(chol(cur_draws$pat_sig))
  for(i in 1:length(samp_info$uni_pat_times)) {
    ## Get full covariance matrix
    dist_mat <- cur_draws$ar ^ samp_info$uni_dist_mat[[i]]
    pat_ind <- min(which(samp_info$pat_time_ind == i))
    time_inv[[i]] <- chol2inv(chol(dist_mat))
    time_det[[i]] <- determinant(dist_mat, logarithm = T)[[1]][1]
    sig_tmp <- kronecker(sigma, dist_mat)  +
      samp_info$pat_z_kron[[pat_ind]] %*% cur_draws$pat_sig %*% t(samp_info$pat_z_kron[[pat_ind]])
    sig_list[[i]] <- sig_tmp
    
    ## Get covariance matrix for marginalized likelihood using the woodbury matrix identity
    A_inv <- kronecker(inv_sigma, chol2inv(chol(dist_mat)))
    sig_inv_use <- A_inv - A_inv %*% samp_info$pat_z_kron[[pat_ind]] %*% (
      sig_alpha_inv + t(samp_info$pat_z_kron[[pat_ind]]) %*% A_inv %*% samp_info$pat_z_kron[[pat_ind]]
    ) %*% t(samp_info$pat_z_kron[[pat_ind]]) %*% A_inv
    sig_inv_list[[i]] <- sig_inv_use
    
    solve(sig_tmp)
    
    ## Calculate pre-calcs and other covariance matrices
    res_tmp <-  pre_calc_ar(sig_tmp,
                            locs = 1:length(samp_info$uni_pat_times[[i]]))
    mean_pre_list[[i]] <- res_tmp$mean_pre
    cond_cov_list[[i]] <- res_tmp$cond_cov
    cond_cov_inv_list[[i]] <- chol2inv(chol(res_tmp$cond_cov))
    marg_cov_list[[i]] <- res_tmp$marg_cov
  }
  list(sig_list = sig_list,
       mean_pre_list = mean_pre_list, cond_cov_list = cond_cov_list,
       cond_cov_inv_list = cond_cov_inv_list, sig_inv_list = sig_inv_list,
       time_inv = time_inv, time_det = time_det,
       marg_cov_list = marg_cov_list)
}


for(i in 1:10) {
  get_DIC_ar(samps_ar, marginal = T)
  print(i)
}
