#if(i %% 150 == 100) plot(res_cuts[4, ], type = "l")
#if(i %% 150 == 100) plot(res_pat_sig_sd[1, ], type = "l")
if(i %% 150 == 50 & i > burn_in) print(round(c(colMeans(res_accept[(burn_in+1):nsim,], na.rm = T), i), 3))
if(i %% 150 == 0) plot(res_pat_sig[1, ], type = "l")
}
prior_siw_uni = c(0.2, 5)
## Create storage
set.seed(seed)
bmrarm_start(env = environment())
cont_out_var <- setdiff(out_vars, ordinal_outcome)
## Starting values for ordinal outcome
y[1:N_obs, 1] <- 0.5 + res_cuts[z, 1]
y[is.infinite(y[, 1]), 1] <- -0.5
y[is.na(y[, 1]), 1] <- 0
## Starting values for continuous outcomes
df <- data.frame(patient = samp_info$pat_idx_long, y = as.numeric(y),
outcome = rep(1:N_outcomes, each = N_obs)) %>%
group_by(patient, outcome) %>%
mutate(y_interp = na.approx(y, na.rm = FALSE),
y_interp = ifelse(!is.na(y_interp), y_interp,
ifelse(row_number() == n(),
lag(y_interp), lead(y_interp))))
y <- matrix(df$y_interp, ncol = N_outcomes)
y[is.na(y)] <- 0
i <- 2
samp_info$burn_in <- burn_in
samp_info$max_iter <- 10000000
## Emprical bayes priors for the random effects covariance matrix
if(random_slope) {
rand_form <- as.formula(paste0("~ ", time_var, "|", patient_var))
} else {
rand_form <- as.formula(paste0("~ 1|", patient_var))
}
ord_form <- reformulate(deparse(formula[[3]]), response = ordinal_outcome)
cont_form <- reformulate(deparse(formula[[3]]), response = cont_out_var)
## Datasets and structures for models
data_ord <- data[!is.na(data[, ordinal_outcome]), ]
data_cont <- data[!is.na(data[, cont_out_var]), ]
cor_struct <- if(ar_cov) {
cor_struct <- corAR1(form = as.formula(~ 1 | pat_idx))
#cor_struct <- NULL
} else {
cor_struct <- NULL
}
## Fit ordinal model
ord_mod <- tryCatch(expr = {
lme(ord_form, data = data_ord, random = rand_form, correlation = cor_struct)
},
error = function(e) {
tryCatch(expr = {
lme(ord_form, data = data_ord, random = rand_form,
correlation = cor_struct, control = lmeControl(opt='optim'))
},
error = function(e) {
## Resort to no AR structure
lme(ord_form, data = data_ord, random = rand_form,
control = lmeControl(opt='optim'))
})
})
## Fit continuous model
cont_mod <- tryCatch(expr = {
lme(cont_form, data = data_cont, random = rand_form,
correlation = cor_struct)
},
error = function(e) {
tryCatch(expr = {
lme(cont_form, data = data_cont, random = rand_form,
correlation = cor_struct, control = lmeControl(opt='optim'))
},
## Resort to no AR structure
error = function(w) {
## Resort to no AR structure
lme(cont_form, data = data_cont, random = rand_form,
control = lmeControl(opt='optim'))
})
})
## Pass prior matrices
priors <- as.numeric(c(VarCorr(ord_mod)[, 1][1:N_pat_effects],
VarCorr(cont_mod)[, 1][1:N_pat_effects]))
prior_mat <- diag(priors)
res_accept <- matrix(NA, nsim, 6)
for(i in 2:nsim) {
samp_info$num_iter <- i
## Regression coefficients
vals <- bmrarm_fc_sig_beta(y, X, Z_kron, cur_draws, samp_info)
res_beta[, i] <- cur_draws$beta <- vals$beta
res_sig[, i] <- cur_draws$sigma <- vals$sig
# Autoregressive parameter
if(samp_info$ar_cov) {
vals <- bmrarm_mh_ar(y, X, Z_kron, cur_draws, samp_info)
cur_draws$ar <- vals$ar
res_accept[i, 2] <- vals$accept
}
res_ar[i] <- cur_draws$ar
## Subject specific effects
# vals <- bmrarm_fc_patient(y, z, X, cur_draws, samp_info, prior_mat)
# res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
# res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects
vals <- bmrarm_fc_patient_siw(y, z, X, cur_draws, samp_info, 1, Z_kron, prior_siw_uni)
res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects
res_pat_sig_q[,i] <- cur_draws$pat_sig_q <- vals$pat_sig_q
res_pat_sig_sd[,i] <- cur_draws$pat_sig_sd <- vals$pat_sig_sd
res_accept[i, 3:6] <- vals$accept_vec
## Latent values, missing values, cut points
y_cuts <- bmrarm_fc_y_cuts(y, z, X, Z_kron, cur_draws, samp_info)
y <-  res_y[,, i] <- y_cuts$y
res_cuts[, i] <- cur_draws$cuts <- y_cuts$cuts
res_accept[i, 1] <- y_cuts$accept
## Update missing values
y <- res_y[,, i]<- bmrarm_fc_missing(y, z, X, Z_kron, cur_draws, samp_info)
## Cut points
#if(i %% 150 == 100) plot(res_cuts[4, ], type = "l")
#if(i %% 150 == 100) plot(res_pat_sig_sd[1, ], type = "l")
if(i %% 150 == 50 & i > burn_in) print(round(c(colMeans(res_accept[(burn_in+1):nsim,], na.rm = T), i), 3))
if(i %% 150 == 0) plot(res_pat_sig[1, ], type = "l")
}
autocorr(mcmc(res_cuts[4, 100:1000]))
plot(res_cuts[4, 100:1000])
plot(res_cuts[4, 100:1000], type = "l")
burn_in
nsim <- 1000
for(i in 2:nsim) {
samp_info$num_iter <- i
## Regression coefficients
vals <- bmrarm_fc_sig_beta(y, X, Z_kron, cur_draws, samp_info)
res_beta[, i] <- cur_draws$beta <- vals$beta
res_sig[, i] <- cur_draws$sigma <- vals$sig
# Autoregressive parameter
if(samp_info$ar_cov) {
vals <- bmrarm_mh_ar(y, X, Z_kron, cur_draws, samp_info)
cur_draws$ar <- vals$ar
res_accept[i, 2] <- vals$accept
}
res_ar[i] <- cur_draws$ar
## Subject specific effects
# vals <- bmrarm_fc_patient(y, z, X, cur_draws, samp_info, prior_mat)
# res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
# res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects
vals <- bmrarm_fc_patient_siw(y, z, X, cur_draws, samp_info, 1, Z_kron, prior_siw_uni)
res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects
res_pat_sig_q[,i] <- cur_draws$pat_sig_q <- vals$pat_sig_q
res_pat_sig_sd[,i] <- cur_draws$pat_sig_sd <- vals$pat_sig_sd
res_accept[i, 3:6] <- vals$accept_vec
## Latent values, missing values, cut points
y_cuts <- bmrarm_fc_y_cuts(y, z, X, Z_kron, cur_draws, samp_info)
y <-  res_y[,, i] <- y_cuts$y
res_cuts[, i] <- cur_draws$cuts <- y_cuts$cuts
res_accept[i, 1] <- y_cuts$accept
## Udate again
new_cut <- runif(1, max(y[z == 2, 1], na.rm = T), min(y[z == 3, 1], na.rm = T))
res_cuts[4:5, i] <- cur_draws$cuts[4:5] / new_cut
y[, 1] <- y[, 1] / new_cut
res_ar[i] <- cur_draws$ar <- cur_draws$ar / new_cut
res_pat_eff[,1:2, i] <- cur_draws$pat_effects[, 1:2]  <- cur_draws$pat_effects[, 1:2] / new_cut
cur_draws$beta <- cur_draws$beta / new_cut
cur_draws$sigma <- diag(c(1 / new_cut, 1)) %*% cur_draws$sigma %*% diag(c(1 / new_cut, 1))
cur_draws$pat_sig_q <- diag(rep(c(1 / new_cut, 1), each = 2)) %*% cur_draws$pat_sig_q %*% diag(rep(c(1 / new_cut, 1), each = 2))
cur_draws$pat_sig <- diag(rep(c(1 / new_cut, 1), each = 2)) %*% cur_draws$pat_sig %*% diag(rep(c(1 / new_cut, 1), each = 2))
vals$pat_sig_sd[1:2] <- vals$pat_sig_sd[1:2] / new_cut
## Update missing values
y <- res_y[,, i]<- bmrarm_fc_missing(y, z, X, Z_kron, cur_draws, samp_info)
## Cut points
if(i %% 150 == 100) plot(res_cuts[4, ], type = "l")
if(i %% 150 == 50 & i +  burn_in) print(round(c(colMeans(res_accept[(burn_in + 1):nsim,], na.rm = T), i), 3))
if(i %% 150 == 0) plot(res_pat_sig[1, ], type = "l")
}
autocorr(mcmc(res_cuts[4, 100:1000]))
plot(res_cuts[4, 100:1000], type = "l")
effectiveSize(mcmc(res_cuts[4, 100:1000]))
i <- 3
sim_data <- gen_ar_errors(N = 6, N_pat = 35, unequal = F, seed = 4,
slope = T, ar_cov = T)
crossprod(sim_data$alpha) / nrow(sim_data$alpha)
crossprod(MASS::mvrnorm(100, mu = c(0, 0, 0, 0) ,Sigma = sim_data$sig_alpha)) / 100
formula = cbind(y_ord, y2) ~ time; data = sim_data$data;
ordinal_outcome = "y_ord"; patient_var = "pat_idx";
random_slope = T; time_var = "time"; ar_cov = T;
burn_in = 100; nsim = 5000; thin = 1; seed = 3;
verbose = TRUE; sig_prior = 1000000000;
sd_vec = c(0.15, 0.30, 0.35, 0.1, 0.25, 0.1)
sd_vec[3:6] <- sd_vec[3:6] * 1
## Create storage
set.seed(seed)
bmrarm_start(env = environment())
## Starting values for ordinal outcome
y[1:N_obs, 1] <- 0.5 + res_cuts[z, 1]
y[is.infinite(y[, 1]), 1] <- -0.5
y[is.na(y[, 1]), 1] <- 0
## Starting values for continuous outcomes
df <- data.frame(patient = samp_info$pat_idx_long, y = as.numeric(y),
outcome = rep(1:N_outcomes, each = N_obs)) %>%
group_by(patient, outcome) %>%
mutate(y_interp = na.approx(y, na.rm = FALSE),
y_interp = ifelse(!is.na(y_interp), y_interp,
ifelse(row_number() == n(),
lag(y_interp), lead(y_interp))))
y <- matrix(df$y_interp, ncol = N_outcomes)
y[is.na(y)] <- 0
i <- 2
samp_info$burn_in <- burn_in
samp_info$max_iter <- 10000000
cur_draws$beta <- matrix(sim_data$beta, 2)
cur_draws$sigma <- sim_data$sigma
cur_draws$ar <- sim_data$ar
cur_draws$pat_sig <- sim_data$sig_alpha
cur_draws$pat_sig_sd <- rep(1, 4)
cur_draws$pat_effects <- sim_data$alpha
res_accept <- matrix(NA, nsim, 6)
y <- y_true<- cbind(sim_data$truth$y1, sim_data$truth$y2)
## Create storage
set.seed(seed)
bmrarm_start(env = environment())
cont_out_var <- setdiff(out_vars, ordinal_outcome)
## Starting values for ordinal outcome
y[1:N_obs, 1] <- 0.5 + res_cuts[z, 1]
y[is.infinite(y[, 1]), 1] <- -0.5
y[is.na(y[, 1]), 1] <- 0
## Starting values for continuous outcomes
df <- data.frame(patient = samp_info$pat_idx_long, y = as.numeric(y),
outcome = rep(1:N_outcomes, each = N_obs)) %>%
group_by(patient, outcome) %>%
mutate(y_interp = na.approx(y, na.rm = FALSE),
y_interp = ifelse(!is.na(y_interp), y_interp,
ifelse(row_number() == n(),
lag(y_interp), lead(y_interp))))
y <- matrix(df$y_interp, ncol = N_outcomes)
y[is.na(y)] <- 0
i <- 2
samp_info$burn_in <- burn_in
samp_info$max_iter <- 10000000
## Emprical bayes priors for the random effects covariance matrix
if(random_slope) {
rand_form <- as.formula(paste0("~ ", time_var, "|", patient_var))
} else {
rand_form <- as.formula(paste0("~ 1|", patient_var))
}
ord_form <- reformulate(deparse(formula[[3]]), response = ordinal_outcome)
cont_form <- reformulate(deparse(formula[[3]]), response = cont_out_var)
## Datasets and structures for models
data_ord <- data[!is.na(data[, ordinal_outcome]), ]
data_cont <- data[!is.na(data[, cont_out_var]), ]
cor_struct <- if(ar_cov) {
cor_struct <- corAR1(form = as.formula(~ 1 | pat_idx))
#cor_struct <- NULL
} else {
cor_struct <- NULL
}
## Fit ordinal model
ord_mod <- tryCatch(expr = {
lme(ord_form, data = data_ord, random = rand_form, correlation = cor_struct)
},
error = function(e) {
tryCatch(expr = {
lme(ord_form, data = data_ord, random = rand_form,
correlation = cor_struct, control = lmeControl(opt='optim'))
},
error = function(e) {
## Resort to no AR structure
lme(ord_form, data = data_ord, random = rand_form,
control = lmeControl(opt='optim'))
})
})
## Fit continuous model
cont_mod <- tryCatch(expr = {
lme(cont_form, data = data_cont, random = rand_form,
correlation = cor_struct)
},
error = function(e) {
tryCatch(expr = {
lme(cont_form, data = data_cont, random = rand_form,
correlation = cor_struct, control = lmeControl(opt='optim'))
},
## Resort to no AR structure
error = function(w) {
## Resort to no AR structure
lme(cont_form, data = data_cont, random = rand_form,
control = lmeControl(opt='optim'))
})
})
## Pass prior matrices
priors <- as.numeric(c(VarCorr(ord_mod)[, 1][1:N_pat_effects],
VarCorr(cont_mod)[, 1][1:N_pat_effects]))
prior_mat <- diag(priors)
res_accept <- matrix(NA, nsim, 6)
for(i in 2:nsim) {
samp_info$num_iter <- i
## Regression coefficients
vals <- bmrarm_fc_sig_beta(y, X, Z_kron, cur_draws, samp_info)
res_beta[, i] <- cur_draws$beta <- vals$beta
res_sig[, i] <- cur_draws$sigma <- vals$sig
# Autoregressive parameter
if(samp_info$ar_cov) {
vals <- bmrarm_mh_ar(y, X, Z_kron, cur_draws, samp_info)
cur_draws$ar <- vals$ar
res_accept[i, 2] <- vals$accept
}
res_ar[i] <- cur_draws$ar
## Subject specific effects
# vals <- bmrarm_fc_patient(y, z, X, cur_draws, samp_info, prior_mat)
# res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
# res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects
vals <- bmrarm_fc_patient_siw(y, z, X, cur_draws, samp_info, 1, Z_kron, prior_siw_uni)
res_pat_sig[, i] <- cur_draws$pat_sig <- vals$pat_sig
res_pat_eff[,, i] <- cur_draws$pat_effects <- vals$pat_effects
res_pat_sig_q[,i] <- cur_draws$pat_sig_q <- vals$pat_sig_q
res_pat_sig_sd[,i] <- cur_draws$pat_sig_sd <- vals$pat_sig_sd
res_accept[i, 3:6] <- vals$accept_vec
## Latent values, missing values, cut points
y_cuts <- bmrarm_fc_y_cuts(y, z, X, Z_kron, cur_draws, samp_info)
y <-  res_y[,, i] <- y_cuts$y
res_cuts[, i] <- cur_draws$cuts <- y_cuts$cuts
res_accept[i, 1] <- y_cuts$accept
## Update missing values
y <- res_y[,, i]<- bmrarm_fc_missing(y, z, X, Z_kron, cur_draws, samp_info)
## Cut points
#if(i %% 150 == 100) plot(res_cuts[4, ], type = "l")
#if(i %% 150 == 100) plot(res_pat_sig_sd[1, ], type = "l")
if(i %% 150 == 50 & i > burn_in) print(round(c(colMeans(res_accept[(burn_in+1):nsim,], na.rm = T), i), 3))
if(i %% 150 == 0) plot(res_pat_sig[1, ], type = "l")
}
effectiveSize(mcmc(res_cuts[4, 100:1000]))
plot(res_cuts[4, 100:1000], type = "l")
autocorr(mcmc(res_cuts[4, 100:1000]))
setwd("C:\\Users\\Nick\\Dropbox\\_Thesis\\bmrvar\\long_sims")
source("../run_apps_sims//helper_functions.R")
## Collect objects
max_mod <- 4
mod_list <- list()
obs <- c(1:max_mod)
## Get all predictions
set.seed(1)
#full_mod$res_beta <- full_mod$res_beta[, 1:5]
#all_preds <- get_pred(full_mod)
#saveRDS(all_preds, "./leish_posterior_preds_updated.RDS")
all_preds <- readRDS("./leish_posterior_preds.RDS")
data <- mod_list[[1]]$data
n_samp <- length(all_preds)
res <- matrix(NA, nrow = 3, ncol = n_samp)
## Collect objects
max_mod <- 1
mod_list <- list()
obs <- c(1:max_mod)
for(i in 1:length(obs)){
mod_list[[i]] <- readRDS(paste0("Z:\\bmrarm\\samples\\leish_data_slope_model_siw_small", i, ".RDS"))
print(mod_list[[i]]$runtime)
}
## Collect objects
max_mod <- 1
mod_list <- list()
obs <- c(1:max_mod)
for(i in 1:length(obs)){
mod_list[[i]] <- readRDS(paste0("Z:\\bmrarm\\samples\\leish_data_slope_model_siw_small", i, ".RDS"))
print(mod_list[[i]]$runtime)
}
## Get all predictions
set.seed(1)
#full_mod$res_beta <- full_mod$res_beta[, 1:5]
#all_preds <- get_pred(full_mod)
#saveRDS(all_preds, "./leish_posterior_preds_updated.RDS")
all_preds <- readRDS("./leish_posterior_preds.RDS")
data <- mod_list[[1]]$data
n_samp <- length(all_preds)
res <- matrix(NA, nrow = 3, ncol = n_samp)
## Continuous outcomes
res2 <- matrix(NA, nrow = 5, ncol = n_samp)
dat_last <- filter(data, time + 1 == max_not_na)
all_preds_keep <- matrix(NA, 48, n_samp)
for(i in 1:n_samp){
dat_last$log_sla_pred <- all_preds[[i]]$last_preds[, 2]
all_preds_keep[, i] <- all_preds[[i]]$last_preds[, 2]
dat_group <- dat_last %>%
summarise(mean(log_sla_pred),
median(log_sla_pred),
sd(log_sla_pred),
min(log_sla_pred),
max(log_sla_pred))
res2[, i] <- unlist(dat_group)
print(i)
}
mean(res2[2, ] >= median(dat_last$log_sla, na.rm = T))
mean(res2[1, ] >= mean(dat_last$log_sla, na.rm = T))
mean(res2[5, ] >= max(dat_last$log_sla, na.rm = T))
1 - mean(res2[5, ] >= max(dat_last$log_sla, na.rm = T))
runif(-1, -2)
runif(1, -1, -2)
remotes::install_github("nickseedorff/totalvis")
## Get data
crimes <- read.csv(paste0("https://archive.ics.uci.edu/ml/machine-learning-",
"databases/00211/CommViolPredUnnormalizedData.txt"),
header = F)
## Add column names
crimes_descr <- readLines(paste0("http://archive.ics.uci.edu/ml/datasets/",
"Communities+and+Crime+Unnormalized"))
crimes_descr <- strsplit(crimes_descr[grepl(pattern = "<br>@attribute",
x = crimes_descr)], split = " ")
colnames(crimes) <- vapply(crimes_descr, FUN = function(rw) {rw[[2]]},
FUN.VALUE = "STRING")
## Replace "?" with NA
crimes[crimes == "?"] <- NA
crimes <- crimes[, colSums(is.na(crimes)) == 0]
## Select a subset of predictors, Convert all columns to numeric, add outcome
col_start <- which(names(crimes) == "pop")
end_start <- which(names(crimes) == "pctOfficDrugUnit")
X <- as.data.frame(sapply(crimes[, col_start:end_start], as.numeric))
outcome <- crimes$murdPerPop
## Train the model
set.seed(2021)
rf_mod <- randomForest(X, outcome)
rf_mod <- randomForest(X, outcome)
library(randomForest)
plot(totalvis(rf_mod, X, pin = "pctKids2Par"))
library(totalvis)
plot(totalvis(rf_mod, X, pin = "pctKids2Par"))
rf_mod <- randomForest(X, outcome)
plot(totalvis(rf_mod, X, pin = "pctKids2Par"))
plot(totalvis(rf_mod, X, feature = "pctKids2Par", pc_num = NULL))
View(X)
which(colnames(X) == pctKids2Par)
which(colnames(X) == "pctKids2Par")
X[, 44, drop = FALSE]
rf_mod2 <- randomForest(X[, 44, drop = FALSE], outcome)
plot(totalvis(rf_mod2, X, pin = "pctKids2Par"))
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"))
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], feature = "pctKids2Par", pc_num = NULL))
plot(totalvis(rf_mod, X, pin = "pctKids2Par"))
plot(totalvis(rf_mod, X, feature = "pctKids2Par", pc_num = NULL))
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"))
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], feature = "pctKids2Par", pc_num = NULL))
hist(X[, 44, drop = FALSE])
hist(X[, 44])
par(mar=c(5.1, 4.1, 1.1, 2.1), mfrow=c(2,2))
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"))
par(mar=c(5.1, 4.1, 0.1, 2.1), mfrow=c(2,2))
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"))
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "")
par(mar=c(5.1, 4.1, 0.5, 2.1), mfrow=c(1, 3))
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "")
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "")
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "", cex.label = 1.5)
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "", cex.label = 10)
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "", cex = 2)
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "", cex.lab=1.5)
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "", cex.axis=1.5)
par(mar=c(5.1, 4.1, 0.5, 2.1), mfrow=c(1, 3), cex = 1.5)
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "", cex.axis=1.5)
par(mar=c(5.1, 4.1, 0.5, 2.1), mfrow=c(1, 3), cex = 1.2)
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "")
par(mar=c(5.1, 4.1, 0.5, 2.1), mfrow=c(1, 3), cex = 1.05)
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "")
par(mar=c(5.1, 4.1, 0.5, 2.1), mfrow=c(1, 3), cex = 0.9)
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "")
par(mar=c(5.1, 4.1, 0.5, 2.1), mfrow=c(1, 3), cex = 0.9)
plot(totalvis(rf_mod, X, pin = "pctKids2Par"), main = "")
plot(totalvis(rf_mod, X, feature = "pctKids2Par", pc_num = NULL), main = "")
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "")
par(mar=c(5.1, 4.1, 0.5, 2.1), mfrow=c(1, 3), cex = 0.9)
plot(totalvis(rf_mod, X, pin = "pctKids2Par"), main = "")
plot(totalvis(rf_mod, X, feature = "pctKids2Par", pc_num = NULL), main = "")
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], pin = "pctKids2Par"), main = "")
par(mar=c(5.1, 4.1, 0.5, 2.1), mfrow=c(1, 3), cex = 0.9)
plot(totalvis(rf_mod, X, pin = "pctKids2Par"), main = "")
plot(totalvis(rf_mod, X, feature = "pctKids2Par", pc_num = NULL), main = "")
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], feature = "pctKids2Par", pc_num = NULL))
par(mar=c(5.1, 3.1, 0.5, 1.1), mfrow=c(1, 3), cex = 0.9)
plot(totalvis(rf_mod, X, pin = "pctKids2Par"), main = "")
plot(totalvis(rf_mod, X, feature = "pctKids2Par", pc_num = NULL), main = "")
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], feature = "pctKids2Par", pc_num = NULL), main = "")
par(mar=c(5.1, 4.1, 0.5, 1.1), mfrow=c(1, 3), cex = 0.9)
plot(totalvis(rf_mod, X, pin = "pctKids2Par"), main = "")
plot(totalvis(rf_mod, X, feature = "pctKids2Par", pc_num = NULL), main = "")
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], feature = "pctKids2Par", pc_num = NULL), main = "")
par(mar=c(5.1, 4.1, 0.5, 0.1), mfrow=c(1, 3), cex = 0.9)
plot(totalvis(rf_mod, X, pin = "pctKids2Par"), main = "")
plot(totalvis(rf_mod, X, feature = "pctKids2Par", pc_num = NULL), main = "")
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], feature = "pctKids2Par", pc_num = NULL), main = "")
plot(totalvis(rf_mod2, X[, 44, drop = FALSE], feature = "pctKids2Par"), main = "")
X_pk2p <- X[, which(colnames(X) == "pctKids2Par"), drop = FALSE]
rf_marg <- randomForest(X_pk2p, outcome)
plot(totalvis(rf_marg, X_pk2p, feature = "pctKids2Par"))
test()
setwd("C:/Users/Nick/Dropbox/_Thesis/bmrvar/packages/bmrarm")
setwd("C:/Users/Nick/Dropbox/_Thesis/bmrvar/packages/bmrarm")
test()
# Correlated feature with no effect ---------------------------------------
library(caret)
set.seed(2021)
X <- mvrnorm(n = 1000, mu = c(2, 2),
Sigma = matrix(c(1, 0.8, 0.8, 1), nrow = 2))
colnames(X) <- c("X1", "X2")
y = as.factor((X[, 1] + rnorm(1000, 0, 0.1)) > 1.5)
## Train model, plot pdp_pca
mod <- train(X, y , method = "nnet", trace = FALSE)
plot(totalvis(mod, X, pin = "X2", type = "classification"))
## Train model, plot pdp_pca
mod <- train(X, y , method = "nnet", trace = FALSE)
library(e1071)
install.packages("e1071")
library(e1071)
## Train model, plot pdp_pca
mod <- train(X, y , method = "nnet", trace = FALSE)
plot(totalvis(mod, X, pin = "X2", type = "classification"))
diag_obj <- partial_effects(mod, X, type = "classification")
plot(diag_obj, differenced = FALSE, legend_loc = "right")
plot(diag_obj, differenced = T, legend_loc = "right")
plot(totalvis(mod, X, feature = "X2", type = "classification"))
plot(totalvis(mod, X, feature = "X1", type = "classification"))
plot(totalvis(mod, X, feature = "X3", type = "classification"))
plot(totalvis(mod, X, feature = "X2", type = "classification"))
mod2 <- train(X[, 2, drop = FALSE], y , method = "nnet", trace = FALSE)
plot(totalvis(mod2, X[, 2, drop = FALSE], feature = "X2", type = "classification"))
